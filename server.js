const http = require('http');
const express = require('express');
const app = express();
const dateFormat = require('dateformat');
const Canvas = require("canvas");
app.get("/", (request, response) => {
  response.sendStatus(200);
});
app.listen(process.env.PORT);
setInterval(() => {
  http.get(`http://system-on.glitch.me/`);
}, 280000);

const Discord = require('discord.js');  
const client = new Discord.Client();  
const moment = require('moment');
const zalgo = require('zalgolize');  
const math = require('math-expression-evaluator');   
const figlet = require('figlet');   
const fs = require('fs');  
const ms = require('ms');  
const prefix = '-'


client.on('message', msg => {  
    if (msg.content === 'ÿ®ÿßŸÉ') {  
      msg.reply('** :wink: ŸàŸêŸÑŸêŸÄŸÉŸèŸÖŸêŸÄ   :sparkling_heart:**');  
    }
  });



  client.on('message', msg => {  
    if (msg.content === 'ÿßÿ≠ÿ®ŸÉ') {  
      msg.reply('**ŸäÿßÿÆŸàŸä ŸÑÿß ÿ™ÿ≠ÿ™ŸÉ -_-**');  
    }
  });


  client.on('message', msg => {  
    if (msg.content === 'ÿßÿ≥ŸÖÿπ') {  
      msg.reply('**Ÿäÿß ÿßŸÑŸÑŸá ŸÜÿ¥ÿ®Ÿá ÿßŸÜÿ™ ÿ¥ÿ™ÿ®Ÿä ŸÇŸàŸÑ**');  
    }
  });



client.on('message', msg => {  
    if (msg.content === 'ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ') {  
      msg.reply('**ŸàÿπŸÄŸÑŸÄŸäŸÉŸÄŸÖ ÿßŸÑŸÄÿ≥ŸÑÿ¢ŸÖ Ÿàÿ±ÿ≠ŸÄŸÖŸÄÿ© ÿßŸÑŸÑŸá Ÿàÿ®ÿ±ŸÉÿßÿ™Ÿá**');  
    }
  });

client.on('message', msg => {  
    if (msg.content === 'ŸÉŸÅŸà') {  
      msg.reply('**ŸÉŸÅŸàŸÉ ÿßŸÑÿ∑Ÿäÿ® **');  
    }
  });

client.on('message', msg => {  
    if (msg.content === 'ÿßÿ±ÿ≠ÿ®') {  
      msg.reply('**ÿßŸÑÿ®ŸÇŸâ **');  
    }
  });

client.on('message', msg => {  
    if (msg.content === 'ÿ®ÿ±ÿ®') {  
      msg.reply('**TyT **');  
    }
  });
  

client.on("message", message => {    
    if(message.content.startsWith(prefix + "emoji")) {   
        if(message.author.bot) return;  
        var emojiid =  message.content.split(" ").slice(1).join(" ")   
        console.log(emojiid) 
        if(emojiid.length < "18" || emojiid.length > "18" || isNaN(emojiid)) return  message.channel.send(`- Usage  
${prefix}emoji <EmojiID>`); 
        else    
        message.channel.send("This is the emoji that you requested:-",  
          { 
            files: [`https://cdn.discordapp.com/emojis/${emojiid}.png`]  
          }) 
        }  
})   



 client.on("message", message => {  
  if (message.channel.type === "dm") {    

      message.channel.startTyping();    
      setTimeout(() => {    
        message.channel.stopTyping();    
      }, Math.random() * (1 - 3) + 1 * 1000);  
   
  }  
});  

const clans = {}; 
const system = {};  
const level = {};  
 


const pics = JSON.parse(fs.readFileSync('./pics.json' , 'utf8'));
 client.on('message', message => {
         if (!message.channel.guild) return;

  let room = message.content.split(" ").slice(1);
  let findroom = message.guild.channels.find('name', `${room}`)
  if(message.content.startsWith(prefix + "setMedia")) {
      if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
      if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
      if(!room) return message.channel.send('Please Type The Channel Name')
      if(!findroom) return message.channel.send('Cant Find This Channel')
      let embed = new Discord.RichEmbed()
      .setTitle('**Done The MediaOnly Code Has Been Setup**')
      .addField('Channel:', `${room}`)
      .addField('Requested By', `${message.author}`)
      .setThumbnail(message.author.avatarURL)
      .setFooter(`${client.user.username}`)
      message.channel.sendEmbed(embed)
      pics[message.guild.id] = {
      channel: room,
      onoff: 'On'
      },
      fs.writeFile("./pics.json", JSON.stringify(pics), (err) => {
      if (err) console.error(err)
      
      })
    }})
       client.on('message', message => {
  
  if(message.content.startsWith(prefix + "toggleMedia")) {
          if (!message.channel.guild) return;

      if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
      if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
      if(!pics[message.guild.id]) pics[message.guild.id] = {
        onoff: 'Off'
      }
        if(pics[message.guild.id].onoff === 'Off') return [message.channel.send(`**The MediaCode Is __ùêéùêç__ !**`), pics[message.guild.id].onoff = 'On']
        if(pics[message.guild.id].onoff === 'On') return [message.channel.send(`**The MediaCode Is __ùêéùêÖùêÖ__ !**`), pics[message.guild.id].onoff = 'Off']
        fs.writeFile("./pics.json", JSON.stringify(pics), (err) => {
          if (err) console.error(err)
          
          })
        }
        
      })
      
             client.on('message', message => {
                       if (!message.channel.guild) return;
  if(message.author.bot) return;
  
        if(!pics[message.guild.id]) pics[message.guild.id] = {
        onoff: 'Off'
      }
        if(pics[message.guild.id].onoff === 'Off') return;

  if(message.channel.name !== `${pics[message.guild.id].channel}`) return;

   let types = [
    'jpg',
    'jpeg',
    'png',
    'http://prntscr.com/'
  ]
   if (message.attachments.size <= 0) {
    message.delete();
    message.channel.send(`${message.author}, This Channel For Media üñºÔ∏è Only !`) 
    .then(msg => {
      setTimeout(() => {
        msg.delete();
      }, 5000)
  })
  return;
}
   if(message.attachments.size >= 1) {
    let filename = message.attachments.first().filename
    console.log(filename);
    if(!types.some( type => filename.endsWith(type) )) {
      message.delete();
      message.channel.send(`${message.author}, This Channel For Media üñºÔ∏è Only !`)
      .then(msg => {
        setTimeout(() => {
          msg.delete();
        }, 5000)
      })
      .catch(err => {
        console.error(err);
    });
    }
  }
 })
client.on('message', message => {
  if(message.content.startsWith(prefix + "infoMedia")) {
let embed = new Discord.RichEmbed()
.addField('Channel Status', `${pics[message.guild.id].onoff}`)
.addField('Media Channel', `${pics[message.guild.id].channel}`)
.addField('Requested By', `${message.author}`)
.setThumbnail(message.author.avatarURL)
.setFooter(`${client.user.username}`)
message.channel.sendEmbed(embed)
  }})

 const kingmas = [
    '*** ŸÖŸÜÿ¥ŸÜ ÿßŸÑÿ¨ŸÖŸäÿπ ŸàŸÇŸÑ ÿßŸÜÿß ÿßŸÉÿ±ŸáŸÉŸÖ. ***',
 '*** ÿßÿ™ÿµŸÑ ÿπŸÑŸâ ÿßŸÖŸÉ Ÿà ŸÇŸàŸÑ ŸÑŸáÿß ÿßŸÜŸÉ ÿ™ÿ≠ÿ®Ÿáÿß :heart:. ***',
    '***     ÿ™ÿµŸÑ ÿπŸÑŸâ ÿßŸÑŸàÿßŸÑÿØŸá  Ÿà ÿ™ŸÇŸàŸÑ ŸÑŸáÿß  ÿßÿ≠ÿ® Ÿàÿ≠ÿØŸá.***',
    '*** ÿ™ÿ™ÿµŸÑ ÿπŸÑŸâ ÿ¥ÿ±ÿ∑Ÿä ÿ™ŸÇŸàŸÑ ŸÑŸá ÿπŸÜÿØŸÉŸÖ ŸÖÿ∑ÿßŸÅŸä.***',
    '*** ÿµŸàÿ± ÿßŸä ÿ¥Ÿäÿ° Ÿäÿ∑ŸÑÿ®Ÿá ŸÖŸÜŸÉ ÿßŸÑÿßÿπÿ®ŸäŸÜ.***',
    '*** ÿßŸÉÿ™ÿ® ŸÅŸä ÿßŸÑÿ¥ÿßÿ™ ÿßŸä ÿ¥Ÿäÿ° Ÿäÿ∑ŸÑÿ®Ÿá ŸÖŸÜŸÉ ÿßŸÑÿßÿπÿ®ŸäŸÜ ŸÅŸä ÿßŸÑÿÆÿßÿµ. ***',
    '*** ÿßÿ™ÿµŸÑ ÿπŸÑŸâ ÿßÿ≠ÿØ ŸÖŸÜ ÿßÿÆŸàŸäÿßŸÉ  ÿÆŸàŸäÿßÿ™ŸÉ , Ÿà ÿßÿ∑ŸÑÿ® ŸÖŸÜŸáŸÖ ŸÖÿ®ŸÑÿ∫ ÿπŸÑŸâ ÿßÿ≥ÿßÿ≥ ÿßŸÜŸÉ ÿµÿØŸÖÿ™ ÿ®ÿ≥Ÿäÿßÿ±ÿ™ŸÉ.***',
    '*** ÿßÿπÿ∑Ÿä ÿßŸä ÿßÿ≠ÿØ ÿ¨ŸÜÿ®ŸÉ ŸÉŸÅ ÿßÿ∞ÿß ŸÖÿßŸÅŸäŸá ÿßÿ≠ÿØ ÿ¨ŸÜÿ®ŸÉ ÿßÿπÿ∑Ÿä ŸÜŸÅÿ≥ŸÉ Ÿà ŸÜÿ®Ÿä ŸÜÿ≥ŸÖÿπ ÿµŸàÿ™ ÿßŸÑŸÉŸÅ.***',
    '***  ÿ™ÿ±Ÿàÿ≠ ÿπŸÜÿØ ÿ¥ÿÆÿµ ÿ™ŸÇŸàŸÑ ŸÑŸá ÿßÿ≠ÿ®ŸÉ. ***',
    '***ÿ±Ÿàÿ≠ ÿπŸÜÿØ ÿßŸä ÿßÿ≠ÿØ ÿ®ÿßŸÑÿÆÿßÿµ Ÿà ŸÇŸàŸÑ ŸÑŸá ÿßŸÜŸÉ ÿ™ÿ≠ÿ®Ÿá Ÿà ÿßŸÑÿÆ.***',
    '*** ÿßÿ∞Ÿáÿ® ÿßŸÑŸâ Ÿàÿßÿ≠ÿØ ŸÖÿßÿ™ÿπÿ±ŸÅŸá ŸàŸÇŸÑ ŸÑŸá ÿßŸÜÿß ŸÉŸäŸàÿ™ Ÿàÿßÿ®Ÿä ÿ®Ÿàÿ≥Ÿá. ***',
    '*** ÿ±Ÿàÿ≠ ÿßŸÑŸâ ÿßŸä ŸÇÿ±Ÿàÿ® ÿπŸÜÿØŸÉ ŸÅŸä ÿßŸÑŸàÿßÿ™ÿ≥ ÿßÿ® Ÿà ÿßŸÉÿ™ÿ® ÿßŸä ÿ¥Ÿäÿ° Ÿäÿ∑ŸÑÿ®Ÿá ŸÖŸÜŸÉ ÿßŸÑÿßÿπÿ®ŸäŸÜ  ÿßŸÑÿ≠ÿØ ÿßŸÑÿßŸÇÿµŸâ 3 ÿ±ÿ≥ÿßÿ¶ŸÑ. ***',
    '*** ÿßÿ∞ÿß ÿßŸÜÿ™ ŸàŸÑÿØ ÿßŸÉÿ≥ÿ± ÿßÿ∫ŸÑŸâ ÿßŸà ÿßÿ≠ÿ≥ŸÜ ÿπÿ∑Ÿàÿ± ÿπŸÜÿØŸÉ ÿßÿ∞ÿß ÿßŸÜÿ™Ÿä ÿ®ŸÜÿ™ ÿßŸÉÿ≥ÿ±Ÿä ÿßŸÑÿ±Ÿàÿ¨ ÿ≠ŸÇŸÉ ÿßŸà ÿßŸÑŸÖŸäŸÉ ÿßÿ® ÿ≠ŸÇŸÉ. ***',
    '*** ÿ∞Ÿä ÿßŸÑŸÖÿ±ÿ© ŸÑŸÉ ŸÑÿß ÿ™ÿπŸäÿØŸáÿß.***',
    '*** ÿßÿ±ŸÖŸä ÿ¨ŸàÿßŸÑŸÉ ÿπŸÑŸâ ÿßŸÑÿßÿ±ÿ∂ ÿ®ŸÇŸàÿ© Ÿà ÿßÿ∞ÿß ÿßŸÜŸÉÿ≥ÿ± ÿµŸàÿ± ÿßŸÑÿ¨ŸàÿßŸÑ Ÿà ÿßÿ±ÿ≥ŸÑŸá ŸÅŸä ÿßŸÑÿ¥ÿßÿ™ ÿßŸÑÿπÿßŸÖ.***',
    '*** ÿßÿ™ÿµŸÑ ÿπŸÑŸâ ÿßÿ®ŸàŸÉ Ÿà ŸÇŸàŸÑ ŸÑŸá ÿßŸÜŸÉ ÿ±ÿ≠ÿ™ ŸÖÿπ ÿ®ŸÜÿ™ Ÿà ÿßÿ≠ŸäŸÜ ŸáŸä ÿ≠ÿßŸÖŸÑ..... ***',
    '*** ÿ™ŸÉŸÑŸÖ ÿ®ÿßŸÑŸÑŸáÿ¨ÿ© ÿßŸÑÿ≥ŸàÿØÿßŸÜŸäÿ© ÿßŸÑŸäŸÜ Ÿäÿ¨Ÿä ÿØŸàÿ±ŸÉ ŸÖÿ±ÿ© ÿ´ÿßŸÜŸäÿ©.***',
    '***ÿ≥Ÿà ŸÖÿ¥ŸáÿØ ÿ™ŸÖÿ´ŸäŸÑŸä ÿπŸÜ ŸÖÿµÿ±Ÿäÿ© ÿ®ÿ™ŸàŸÑÿØ.***',
    '*** ŸÇŸàŸÑ ŸÜŸÉÿ™ÿ© ÿßÿ∞ÿß Ÿà ŸÑÿßÿ≤ŸÖ ÿßÿ≠ÿØ ÿßŸÑÿßÿπÿ®ŸäŸÜ Ÿäÿ∂ÿ≠ŸÉ ÿßÿ∞ÿß ŸÖÿ≠ÿØ ÿ∂ÿ≠ŸÉ Ÿäÿπÿ∑ŸàŸÜŸÉ ŸÖŸäŸàÿ™ ÿßŸÑŸâ ÿßŸÜ Ÿäÿ¨Ÿä ÿØŸàÿ±ŸÉ ŸÖÿ±ÿ© ÿ´ÿßŸÜŸäÿ©. ***',
    '*** ŸÇŸàŸÑ ŸÜŸÉÿ™ÿ© ÿßÿ∞ÿß Ÿà ŸÑÿßÿ≤ŸÖ ÿßÿ≠ÿØ ÿßŸÑÿßÿπÿ®ŸäŸÜ Ÿäÿ∂ÿ≠ŸÉ ÿßÿ∞ÿß ŸÖÿ≠ÿØ ÿ∂ÿ≠ŸÉ Ÿäÿπÿ∑ŸàŸÜŸÉ ŸÖŸäŸàÿ™ ÿßŸÑŸâ ÿßŸÜ Ÿäÿ¨Ÿä ÿØŸàÿ±ŸÉ ŸÖÿ±ÿ© ÿ´ÿßŸÜŸäÿ©.***',
    '*** ÿ≥ÿßŸÖÿ≠ÿ™ŸÉ ÿÆŸÑÿßÿµ ŸÖÿßŸÅŸäŸá ÿπŸÇÿßÿ® ŸÑŸÉ :slight_smile:. ***',
    '*** ÿßÿ∞Ÿáÿ® ÿßŸÑŸâ Ÿàÿßÿ≠ÿØ ŸÖÿßÿ™ÿπÿ±ŸÅŸá ŸàŸÇŸÑ ŸÑŸá ÿßŸÜÿß ŸÉŸäŸàÿ™ Ÿàÿßÿ®Ÿä ÿ®Ÿàÿ≥Ÿá.***',
    '*** ÿ™ÿ™ÿµŸÑ ÿπŸÑŸâ ÿßŸÑŸàÿßŸÑÿØŸá  Ÿà ÿ™ŸÇŸàŸÑ ŸÑŸáÿß ÿÆÿ∑ŸÅÿ™ ÿ¥ÿÆÿµ. ***',
    '*** ÿ±Ÿàÿ≠ ÿßŸÉŸÑ ŸÖŸÑÿ≠ + ŸÑŸäŸÖŸàŸÜ ÿßÿ∞ÿß ŸÖÿßŸÅŸäŸá ÿßŸÉŸÑ ÿßŸä ÿ¥Ÿäÿ° ŸÖŸÜ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸä ŸÖÿπŸÉ.  ***'
 ]
  client.on('message', message => {
    var prefix = '-';
  if (message.content.startsWith(prefix + 'ÿ≠ŸÉŸÖ')) {
   var mariam= new Discord.RichEmbed()
   .setTitle("ŸÑÿπÿ®ÿ© ÿ≠ŸÉŸÖ ..")
   .setColor('RANDOM')
   .setDescription(`${kingmas[Math.floor(Math.random() * kingmas.length)]}`)
    message.channel.sendEmbed(mariam);
    message.react(":thinking:")
   }
 });

client.on('message', PuP => {
  let args = PuP.content.split(" ").slice(1).join(" ")
  if (PuP.content.startsWith(`${prefix}sr`)) {
                if (!PuP.member.hasPermission("MANAGE_SERVER"))  return;
                if(!args) return PuP.channel.send('`**Ÿäÿ±ÿ¨Ÿä ÿßÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿ≥ÿ±ŸÅÿ± ÿßŸÑÿ¨ÿØŸäÿØ**`');
                PuP.guild.owner.send(`**Ÿâ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ≥ÿ±ŸÅÿ± ÿßŸÑŸä ${args}
                ÿ®Ÿàÿßÿ≥ÿ∑ÿ© : <@${PuP.author.id}>**`)
                PuP.guild.setName(args)
                PuP.channel.send(`**ÿ™ŸÖ ÿ™ÿ∫Ÿäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ÿßŸÑŸä : __${args}__ **`);
                
       }

       });


client.on('ready', function(){
    var ms = 10000 ;
    var setGame = ['-help'];
    var i = -1;
    var j = 0;
    setInterval(function (){
        if( i == -1 ){
            j = 1;
        }
        if( i == (setGame.length)-1 ){
            j = -1;
        }
        i = i+j;
        client.user.setGame(setGame[i],``);
    }, ms);
  console.log(`Logged in as ${client.user.tag}!`);
  console.log('')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó')
  console.log(`[Start] ${new Date()}`);
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó');
  console.log(`Logged in as * [ " ${client.user.username} " ]`);
  console.log('')
  console.log('Informations :')
  console.log('')
  console.log(`servers! [ " ${client.guilds.size} " ]`);
  console.log(`Users! [ " ${client.users.size} " ]`);
  console.log(`channels! [ " ${client.channels.size} " ]`);
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó')
  console.log(' Bot Is Online')
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('')
});


client.on('message', message => {
var prefix = "-";
      if(message.content === prefix + "hchannel") {
      if(!message.channel.guild) return;
      if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply('You Dont Have Perms :x:');
             message.channel.overwritePermissions(message.guild.id, {
             READ_MESSAGES: false
 })
              message.channel.send('Channel Hided Successfully ! :white_check_mark:  ')
 }
});

client.on('message',async Epic => {
  var prefix = "-" ;
  if(Epic.content.startsWith(prefix + "vonline")) {
  if(!Epic.guild.member(Epic.author).hasPermissions('MANAGE_CHANNELS')) return Epic.reply(':x: **I Dont Have Permissions**');
  if(!Epic.guild.member(client.user).hasPermissions(['MANAGE_CHANNELS','MANAGE_ROLES_OR_PERMISSIONS'])) return Epic.reply(':x: **You Dont Have Permissions**');
  Epic.guild.createChannel(`Voice Online : [ ${Epic.guild.members.filter(m => m.voiceChannel).size} ]` , 'voice').then(c => {
    console.log(`Voice Online Is Activation In ${Epic.guild.name}`);
    c.overwritePermissions(Epic.guild.id, {
      CONNECT: false,
      SPEAK: false
    });
    setInterval(() => {
      c.setName(`Voice Online :  ${Epic.guild.members.filter(m => m.voiceChannel).size} .`)
    },1000);
  });
  }
});


client.on('message', message => {
var prefix = "-";
var cats = ["http://www.shuuf.com/shof/uploads/2015/09/09/jpg/shof_b9d73150f90a594.jpg","https://haltaalam.info/wp-content/uploads/2015/05/0.208.png","https://haltaalam.info/wp-content/uploads/2015/05/266.png","https://haltaalam.info/wp-content/uploads/2015/05/250.png","https://haltaalam.info/wp-content/uploads/2017/02/0.2517.png","https://pbs.twimg.com/media/CP0mi02UAAA3U2z.png","http://www.shuuf.com/shof/uploads/2015/08/31/jpg/shof_3b74fa7295ec445.jpg","http://www.shuuf.com/shof/uploads/2015/08/22/jpg/shof_fa3be6ab68fb415.jpg","https://pbs.twimg.com/media/CSWPvmRUcAAeZbt.png","https://pbs.twimg.com/media/B18VworIcAIMGsE.png"]
        var args = message.content.split(" ").slice(1);
    if(message.content.startsWith(prefix + 'ŸáŸÑ ÿ™ÿπŸÑŸÖ')) {
         var cat = new Discord.RichEmbed()
.setImage(cats[Math.floor(Math.random() * cats.length)])
message.channel.sendEmbed(cat);
    }
});



client.on('message', message => {
var prefix = "-";
      if(message.content === prefix + "schannel") {
      if(!message.channel.guild) return;
      if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply(':x:');
             message.channel.overwritePermissions(message.guild.id, {
             READ_MESSAGES: true
 })
              message.channel.send('Done  ')
 }
});

client.on('message', message=> {
    if (message.author.bot) return;
    if (message.isMentioned(client.user))
    {
    message.reply("**ÿßŸÜŸÇŸÑÿπ ŸÑÿß ÿ™ŸÖŸÜÿ¥ŸÜ ŸÖÿ±ÿ© ÿ´ÿßŸÜŸäÿ© !**")
    }
});


client.on("message", async message => {
  if(message.author.bot) return;
  if(message.channel.type === "dm") return;

  let prefix = "-";
  let messageArray = message.content.split (" ");
  let cmd = messageArray[0];
  let args = messageArray.slice(1);



if(cmd === `#{prefix}8ball`){


if(!args[1]) return message.reply("Please ask a full question!");
let replies = ["Yes", "No.", "I don't know.", "Ask again later plez."];

  let result = Math.floor((Math.random() * replies.length));
  let question = args.slice(1).join(" ");

  let ballembed = new Discord.RichEmbed ()
  .setAuthor(message.author.tag)
  .setColor("#FF9900")
  .addField("Question", question)
  .addField("Answer", replies[result]);

  message.channel.send(ballembed);
}
});

const Love = [  "**ÿßÿ≠ÿ®ŸÉ / ÿπÿØÿØ ŸÇÿ∑ÿ±ÿßÿ™ ÿßŸÑŸÖŸÄŸÄŸÄÿ∑ÿ± ŸàÿßŸÑÿ¥ÿ¨ÿ± ŸàÿßŸÖŸàÿßÿ¨ ÿßŸÑÿ®ÿ≠ÿ± ŸàÿßŸÑŸÜÿ¨ŸàŸÖ ÿßŸÑŸä ÿ™ÿ™ÿ≤ÿßÿ≠ŸÖ ŸÖÿ®ŸáŸàÿ±ÿ© ŸÅŸä ÿ¨ŸÖÿßŸÑ ÿßŸÑŸÇŸÖÿ±**.",  "**ÿ≥ÿßÿπÿ≤ŸÅŸÉ Ÿàÿ≥ÿßÿ¨ÿπŸÑŸÉ ŸÑÿ≠ŸÜÿß ÿ™ÿ∫ŸÜŸä ÿπŸÑŸäŸá ÿ¨ŸÖŸäÿπ ŸÇÿµÿßÿ¶ÿØ ÿßŸÑÿπÿ¥ŸÄŸÄŸÇ**.",  "**ÿßÿ≠ÿ®ŸÉ ŸÖŸàÿ™... ŸÑÿßÿ™ÿ≥ÿ£ŸÑŸÜŸä ŸÖÿß ÿßŸÑÿØŸÑŸäŸÑ ÿßÿ±ÿ£Ÿäÿ™ ÿ±ÿµÿßÿµŸá ÿ™ÿ≥ÿ£ŸÑ ÿßŸÑŸÇÿ™ŸäŸÑÿü**.",  "**ÿ±ÿ®ŸÖÿß Ÿäÿ®Ÿäÿπ ÿßŸÑÿßŸÜÿ≥ÿßŸÜ ÿ¥Ÿäÿ¶ÿß ŸÇÿØ ÿ¥ÿ±ÿßŸá ŸÑÿßŸÉŸÜ ŸÑÿß Ÿäÿ®Ÿäÿπ ŸÇŸÑÿ®ÿß ŸÇÿØ ŸáŸàÿßŸá**.",  "**Ÿà ŸÖÿß ÿπÿ¨ÿ®Ÿä ŸÖŸàÿ™ ÿßŸÑŸÖÿ≠ÿ®ŸäŸÜ ŸÅŸä ÿßŸÑŸáŸàŸâ ........... Ÿà ŸÑŸÉŸÜ ÿ®ŸÇÿßÿ° ÿßŸÑÿπÿßÿ¥ŸÇŸäŸÜ ÿπÿ¨Ÿäÿ®**.",   "**ÿ≠ŸÑŸÅÿ™ / ŸÑÿßÿ≠ÿ¥ŸÄŸÄŸÄÿØ ÿ¨ŸäŸàÿ¥ ÿßŸÑÿ≠ÿ® Ÿàÿßÿ≠ÿ™ŸÑŸÉ ŸÖÿ≥ŸÉŸäŸÜ ÿ±ÿ®Ÿä ÿ®ŸÑÿßŸÉ ÿ®ÿπŸÄŸÄŸÄÿßÿ¥ŸÇ ÿßÿ±ŸáŸÄŸÄŸÄÿßÿ®Ÿä**.",   "**ÿßŸÑÿπŸäŸÄŸÄŸÜ ÿ™ÿπÿ¥ŸÇ ÿµŸàÿ±ÿ™ŸÉ ... ŸàÿßŸÑŸÇŸÑÿ® Ÿäÿ¨ÿ±Ÿä ŸÅŸäŸá ÿØŸÖŸÉ ŸàŸÉŸÑ ŸÖÿßÿßÿ≥ŸÖÿπ ÿµŸàÿ™ŸÉ ...ÿ¥ŸÅÿßŸäŸÅŸä ÿ™ŸÇŸàŸÑ ÿßÿ≠ÿ®ŸÉ**.",   "**Ÿäÿßÿ≠ÿ∏ ÿßŸÑŸÖŸÉÿßŸÜ ŸÅŸäŸÉ..Ÿäÿßÿ≠ÿ∏ ŸÖŸÜ ŸáŸÖ ÿ≠ŸàÿßŸÑŸäŸÉ ...Ÿäÿßÿ≠ÿ∏ ÿßŸÑŸÜÿßÿ≥ ÿ™ÿ¥ŸàŸÅŸÉ ... ŸàÿßŸÜÿß ŸÖÿ¥ÿ™ÿßŸÇ ÿßŸÑŸäŸÉ**.",   "**ŸÑŸà ŸÉŸÜÿ™ ÿØŸÖÿπÿ© ÿØÿßÿÆŸÑ ÿπŸäŸàŸÜŸä ÿ®ÿ∫ŸÖÿ∂ ÿπŸÑŸäŸÉ ŸàÿµÿØŸÇŸä ŸÖÿß ÿ±ÿßÿ≠ ÿßŸÅÿ™ÿ≠...ŸàŸÑŸà ŸÉÿßŸÜ ÿßŸÑÿ´ŸÖŸÜ ÿπŸäŸàŸÜŸä**.",   "**ÿ≥ŸáŸÑ ÿßŸÖŸàÿ™ ÿπÿ¥ÿßŸÜŸÉ ŸÑŸÉŸÜ ÿßŸÑÿµÿπÿ® ÿßÿπŸäÿ¥ ÿ®ÿØŸàŸÜŸÉ ÿ≥ŸáŸÑ ÿßÿ≠ÿ®ŸÉ ŸÑŸÉŸÜ ÿµÿπÿ® ÿßŸÜÿ≥ÿßŸÉ**.",   "**ÿ£ÿÆÿ¥Ÿâ ÿßŸÜ ÿßŸÜÿ∏ÿ± ŸÑÿπŸäŸÜÿßŸÉ Ÿàÿ£ŸÜÿß ŸÅŸâ ÿ¥ŸàŸÇ ŸàŸÑŸáŸäÿ® ŸÑÿ±ÿ§ŸäÿßŸÉ**.",   "**ÿ£ÿ™ŸÖŸÜŸâ ÿßŸÜ ÿßŸÉŸàŸÜ ÿØŸÖÿπÿ© ÿ™ŸàŸÑÿØ ÿ®ÿπŸäŸÜŸäŸÉ ŸàÿßÿπŸäÿ¥ ÿπŸÑŸâ ÿÆÿØŸäŸÉ ŸàÿßŸÖŸàÿ™ ÿπŸÜÿØ ÿ¥ŸÅÿ™ŸäŸÉ**.",   "**ÿ£ÿ≠ŸäÿßŸÜÿßŸã ÿ£ÿ±Ÿâ ÿßŸÑÿ≠Ÿäÿßÿ© ŸÑÿß ÿ™ÿ≥ÿßŸàŸâ ÿ•ÿ®ÿ™ÿ≥ÿßŸÖÿ© ŸÑŸÉŸÜ ÿØÿßÿ¶ŸÖÿßŸã ÿ•ÿ®ÿ™ÿ≥ÿßŸÖÿ™ŸÉ ŸáŸâ ŸÉŸäÿßŸÜŸâ**.",   "**ŸÖŸÜ ÿßŸÑÿ≥ŸáŸÑ ÿ£ŸÜ ŸäŸÜÿ≥Ÿâ ÿßŸÑÿßŸÜÿ≥ÿßŸÜ ŸÜŸÅÿ≥Ÿá .. ŸÑŸÉŸÜ ŸÖŸÜ ÿßŸÑÿµÿπÿ® ÿßŸÜ ŸäŸÜÿ≥Ÿâ ŸÜŸÅÿ≥ÿßŸã ÿ≥ŸÉŸÜÿ™ ŸÜŸÅÿ≥Ÿá !**.",   "**ŸÜŸÅÿ≥Ÿâ ÿ£ŸÉŸàŸÜ ŸÜÿ¨ŸÖÿ© ÿ≥ŸÖÿßŸÉ .. ŸáŸÖÿ≥ÿ© ÿ¥ŸÅÿßŸÉ .. ÿ¥ŸÖÿπÿ© ŸÖÿ≥ÿßŸÉ .. ÿ®ÿ≥ ÿ™ÿ®ŸÇŸâ ŸÖÿπÿßŸäÿß ŸàÿßŸÜÿß ŸÖÿπÿßŸÉ**.",   "**ÿ£ŸáŸÜÿ¶ ŸÇŸÑÿ®Ÿâ ÿ®ÿ≠ÿ®ŸÉ Ÿàÿµÿ®ÿ± ÿπŸäŸÜŸâ ŸÅŸâ ÿ®ÿπÿØŸÉ Ÿàÿ£ŸÇŸàŸÑ ÿ•ŸÜŸÉ ŸÜŸàÿ± ÿπŸäŸÜŸâ Ÿäÿ¨ÿπŸÑ ÿ±Ÿàÿ≠Ÿâ ŸÅÿØŸâ ŸÇŸÑÿ®ŸÉ**.", ]


 client.on('message', message => {
   if (message.content.startsWith("P.love")) {
                if(!message.channel.guild) return message.reply('** This command only for servers**');
  var embed = new Discord.RichEmbed()
  .setColor(0xd3d0c4)
     .setFooter(`PuP System`)
   .setThumbnail(message.author.avatarURL) 
 .addField('ÿ≠ÿ®' ,
  `${Love[Math.floor(Math.random() * Love.length)]}`)
  message.channel.sendEmbed(embed);
    }
});

client.on("message", message => {
        let roleembed = new Discord.RichEmbed()
    .setDescription(`
    ÿ£ŸÖÿ´ŸÑŸá ÿπŸÑŸâ ÿßŸÑÿ£ŸàÿßŸÖÿ± :
    -role @mention rolename : ŸÑÿ£ÿπÿ∑ÿßÿ° ÿ±ÿ™ÿ®ÿ© ŸÑÿπÿ∂Ÿà ŸÖÿπŸäŸÜ
    -role all rolename : ŸÑÿ£ÿπÿ∑ÿßÿ° ÿ±ÿ™ÿ®ÿ© ŸÑŸÑÿ¨ŸÖŸäÿπ
    -role humans rolename : ŸÑÿ£ÿπÿ∑ÿßÿ° ÿ±ÿ™ÿ®ÿ© ŸÑŸÑÿßÿ¥ÿÆÿßÿµ ŸÅŸÇÿ∑
    -role bots rolename : ŸÑÿ£ÿπÿ∑ÿßÿ° ÿ±ÿ™ÿ®ÿ© ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑÿ®Ÿàÿ™ÿßÿ™`)
    .setFooter('Requested by '+message.author.username, message.author.avatarURL)
      var args = message.content.split(' ').slice(1);
      var msg = message.content.toLowerCase();
      if( !message.guild ) return;
      if( !msg.startsWith( prefix + 'role' ) ) return;
      if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(' **__ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿßÿ™__**');
      if( msg.toLowerCase().startsWith( prefix + 'roleembed' ) ){
          if( !args[0] ) return message.channel.sendEmbed(roleembed)
          if( !args[1] ) return message.channel.sendEmbed(roleembed)
          var role = msg.split(' ').slice(2).join(" ").toLowerCase();
          var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first();
          if( !role1 ) return message.reply( '**:x: Ÿäÿ±ÿ¨Ÿâ Ÿàÿ∂ÿπ ÿßŸÑÿ±ÿ™ÿ®ÿ© ÿßŸÑŸÖÿ±ÿßÿØ ÿßÿπÿ∑ÿßÿ°Ÿáÿß ÿßŸÑŸâ ÿßŸÑÿ¥ÿÆÿµ**' );if( message.mentions.members.first() ){
              message.mentions.members.first().addRole( role1 );
              return message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ±ÿ™ÿ®ÿ© [ '+args[0]+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° ÿßŸÑŸâ **');
          }
          if( args[0].toLowerCase() == "all" ){
              message.guild.members.forEach(m=>m.addRole( role1 ))
              return  message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° ÿßŸÑŸâ ÿßŸÑŸÉŸÑ ÿ±ÿ™ÿ®ÿ©**');
          } else if( args[0].toLowerCase() == "bots" ){
              message.guild.members.filter(m=>m.user.bot).forEach(m=>m.addRole(role1))
              return  message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° ÿßŸÑŸâ ÿßŸÑÿ®Ÿàÿ™ÿßÿ™ ÿ±ÿ™ÿ®ÿ©**');
          } else if( args[0].toLowerCase() == "humans" ){
              message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.addRole(role1))
              return  message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° ÿßŸÑŸâ ÿßŸÑÿ®ÿ¥ÿ±ŸäŸäŸÜ ÿ±ÿ™ÿ®ÿ©**');
          }  
      } else {
          if( !args[0] ) return message.reply( '**:x: Ÿäÿ±ÿ¨Ÿâ Ÿàÿ∂ÿπ ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑŸÖÿ±ÿßÿØ ÿßÿπÿ∑ÿßÿ¶Ÿáÿß ÿßŸÑÿ±ÿ™ÿ®ÿ©**' );
          if( !args[1] ) return message.reply( '**:x: Ÿäÿ±ÿ¨Ÿâ Ÿàÿ∂ÿπ ÿßŸÑÿ±ÿ™ÿ®ÿ© ÿßŸÑŸÖÿ±ÿßÿØ ÿßÿπÿ∑ÿßÿ¶Ÿáÿß ŸÑŸÑÿ¥ÿÆÿµ**' );
          var role = msg.split(' ').slice(2).join(" ").toLowerCase();
          var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first();
          if( !role1 ) return message.reply( '**:x: Ÿäÿ±ÿ¨Ÿâ Ÿàÿ∂ÿπ ÿßŸÑÿ±ÿ™ÿ®ÿ© ÿßŸÑŸÖÿ±ÿßÿØ ÿßÿπÿ∑ÿßÿ¶Ÿáÿß ŸÑŸÑÿ¥ÿÆÿµ**' );if( message.mentions.members.first() ){
              message.mentions.members.first().addRole( role1 );
              return message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ±ÿ™ÿ®ÿ© [ '+args[0]+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° **');
          }
          if( args[0].toLowerCase() == "all" ){
              message.guild.members.forEach(m=>m.addRole( role1 ))
              return  message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° ÿßŸÑŸÉŸÑ ÿ±ÿ™ÿ®ÿ©**');
          } else if( args[0].toLowerCase() == "bots" ){
              message.guild.members.filter(m=>m.user.bot).forEach(m=>m.addRole(role1))
              return  message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° ÿßŸÑÿ®Ÿàÿ™ÿßÿ™ ÿ±ÿ™ÿ®ÿ©**');
          } else if( args[0].toLowerCase() == "humans" ){
              message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.addRole(role1))
              return  message.reply('**:white_check_mark: [ '+role1.name+' ] ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° ÿßŸÑÿ®ÿ¥ÿ±ŸäŸäŸÜ ÿ±ÿ™ÿ®ÿ©**');
          }
      }
  });



client.on("message", (message) => {
     
   if (message.content.startsWith("-new")) {
        const reason = message.content.split(" ").slice(1).join(" ");      
        if (!message.guild.roles.exists("name", "Support Team")) return message.channel.send(`This server doesn't have a \`Support Team\` role made, so the ticket won't be opened.\nIf you are an administrator, make one with that name exactly and give it to users that should be able to see tickets.`);
        if (message.guild.channels.exists("name", "ticket-{message.author.id}" + message.author.id)) return message.channel.send(`You already have a ticket open.`);     
        message.guild.createChannel(`ticket-${message.author.username}`, "text").then(c => {
            let role = message.guild.roles.find("name", "Support Team");
            let role2 = message.guild.roles.find("name", "@everyone");
            c.overwritePermissions(role, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });     
            c.overwritePermissions(role2, {
                SEND_MESSAGES: false,
                READ_MESSAGES: false
            });
            c.overwritePermissions(message.author, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });
            message.channel.send(`:white_check_mark: Your ticket has been created, #${c.name}.`);
            const embed = new Discord.RichEmbed()
                .setColor(0xCF40FA)
                .addField(`Hey ${message.author.username}!`, `Please try explain why you opened this ticket with as much detail as possible. Our **Support Staff** will be here soon to help.`)
                .setTimestamp();
            c.send({
                embed: embed
            });
        }).catch(console.error);
    }
 
 
  if (message.content.startsWith("-close")) {
        if (!message.channel.name.startsWith(`ticket-`)) return message.channel.send(`You can't use the close command outside of a ticket channel.`);
 
       message.channel.send(`Are you sure? Once confirmed, you cannot reverse this action!\nTo confirm, type \`-confirm\`. This will time out in 10 seconds and be cancelled.`)
           .then((m) => {
               message.channel.awaitMessages(response => response.content === '-confirm', {
                       max: 1,
                       time: 10000,
                       errors: ['time'],
                   })     
                   .then((collected) => {
                       message.channel.delete();
                   })     
                   .catch(() => {
                       m.edit('Ticket close timed out, the ticket was not closed.').then(m2 => {
                           m2.delete();
                       }, 3000);
                   });
           });
   }
 
});

let antihack = JSON.parse(fs.readFileSync('./antihack.json' , 'utf8'));
client.on('message', message => { 
    if(message.content.startsWith(prefix + "tAntihack")) { 
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**'); 
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' ); 
        if(!antihack[message.guild.id]) antihack[message.guild.id] = { 
          onoff: 'Off'
        } 
          if(antihack[message.guild.id].onoff === 'Off') return [message.channel.send(`**‚úÖ The AntiHack Is __ùêéùêç__ !**`), antihack[message.guild.id].onoff = 'On']
          if(antihack[message.guild.id].onoff === 'On') return [message.channel.send(`**‚õî The AntiHack Is __ùêéùêÖùêÖ__ !**`), antihack[message.guild.id].onoff = 'Off']
          fs.writeFile("./antihack.json", JSON.stringify(antihack), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            });
          }
 
        })
        
 
  let banse = new Set();
  let bane = JSON.parse(fs.readFileSync('./data1.json' , 'utf8'));
  client.on('guildBanAdd', function(guild) {
    guild.fetchAuditLogs().then(logs => {
      const ser = logs.entries.first().executor;
      if(!bane[ser.id+guild.id]) bane[ser.id+guild.id] = {
        bans: 2
      }
      if(antihack[guild.guild.id].onoff === 'Off') return;
      let boner = bane[ser.id+guild.id]
  banse.add(ser.id)
  boner.bans = Math.floor(boner.bans+1)
 
 
  setTimeout(() => {
    boner.bans = 2
    banse.delete(ser.id)
  },8000)
 
  if(boner.bans > 2) {
    let roles = guild.members.get(ser.id).roles.array()
  guild.members.get(ser.id).removeRoles(roles)
  }
 
      })
      fs.writeFile('./data1.json', JSON.stringify(bane), (err) => {
  if (err) console.error(err);
  })
 
  })
  client.on('guildMemberRemove', (u) => {
      u.guild.fetchAuditLogs().then( s => {
          var ss = s.entries.first();
          if (ss.action == `MEMBER_KICK`) {
          if (!data[ss.executor.id]) {
              data[ss.executor.id] = {
              time : 1
            };
            if(antihack[u.guild.id].onoff === 'Off') return;
 
        } else {  
            data[ss.executor.id].time+=1
        };
        if(antihack[u.guild.id].onoff === 'Off') return;
  data[ss.executor.id].time = 0
  u.guild.members.get(ss.executor.id).roles.forEach(r => {
                  r.edit({
                      permissions : []
                  });
                  data[ss.executor.id].time = 0
              });
          setTimeout(function(){
              if (data[ss.executor.id].time <= 3) {
                  data[ss.executor.id].time = 0
              }
          })
      };
      });
    const data = require("./data.json");
  });
  client.on('roleDelete', (u) => {
      u.guild.fetchAuditLogs().then( s => {
          var ss = s.entries.first();
          if (ss.action == `ROLE_DELETE`) {
          if (!data[ss.executor.id]) {
              data[ss.executor.id] = {
              time : 1
            };
            if(antihack[u.guild.id].onoff === 'Off') return;
 
        } else {
            data[ss.executor.id].time+=1
        };
        if(antihack[u.guild.id].onoff === 'Off') return;
 
  data[ss.executor.id].time = 0
  u.guild.members.get(ss.executor.id).roles.forEach(r => {    
                  r.edit({
                      permissions : []  
                  });
                  data[ss.executor.id].time = 0
              });
          setTimeout(function(){
              if (data[ss.executor.id].time <= 3) {
                  data[ss.executor.id].time = 0
              }
          },60000)
      };
      });
    const data = require("./data.json");
  });
  client.on('channelDelete', (u) => {   
      u.guild.fetchAuditLogs().then( s => {  
          var ss = s.entries.first();
          if (ss.action == `CHANNEL_DELETE`) {  
          if (!data[ss.executor.id]) {
              data[ss.executor.id] = {  
              time : 1
            };
            if(antihack[u.guild.id].onoff === 'Off') return;
        } else {
            data[ss.executor.id].time+=1
        };
        if(antihack[u.guild.id].onoff === 'Off') return;
  data[ss.executor.id].time = 0
  u.guild.members.get(ss.executor.id).roles.forEach(r => {
                  r.edit({
                      permissions : []
                  });
                  data[ss.executor.id].time = 0
              });
          setTimeout(function(){
              if (data[ss.executor.id].time <= 3) {  
                  data[ss.executor.id].time = 0
              }
          })
      };
      });  
    const data = require("./data.json");
  })

client.on('message', message => {
    if (message.content.startsWith("-link")) {

  message.channel.createInvite({
        thing: true,
        maxUses: 100,
        maxAge: 86400
    }).then(invite =>
      message.author.sendMessage(invite.url)
    )
  message.channel.send("**:link:.ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿ®ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿßÿµÿ©**")

message.author.send(`**ŸÖÿØÿ© ÿßŸÑÿ±ÿßÿ®ÿ∑ : ŸäŸÄŸàŸÖ
ÿπÿØÿØ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖÿßÿ™ ÿßŸÑÿ±ÿßÿ®ÿ∑ : 100**`)


    }
});



client.on('message', message=>{  
    if(message.author.bot) return;  
    if(!message.channel.guild) return;
    if(message.content.startsWith(prefix+'setlog')) {  
    if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply("**ÿ™ÿ≠ÿ™ÿßÿ¨ ÿßŸÑŸâ `MANAGE_CHANNELS`**");
    let log = message.guild.channels.find("name", "log")  
    if(log) return message.reply("**ŸäŸàÿ¨ÿØ ÿ®ÿßŸÑŸÅÿπŸÑ ÿ±ŸàŸÖ ÿßŸÑŸÑŸàŸÇ**")   
    if(!log) {   
    message.guild.createChannel("log", "text").then(c=> {  
        c.overwritePermissions(message.guild.id, {  
            SEND_MESSAGES: false
    })
})
message.channel.send("**‚úÖ ,ÿ™ŸÖ ÿßŸÜÿ¥ÿßÿ° ÿ±ŸàŸÖ ÿßŸÑŸÑŸàŸÇ ÿ®ŸÜÿ¨ŸÄŸÄÿßÿ≠**")
    }
    }  
     })
client.on('error', console.error);
 
client.on('messageDelete', message => {  
    if(message.author.bot) return;
    if(message.channel.type === 'dm') return;  
    if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return;  
    if(!message.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;  
 
    var logChannel = message.guild.channels.find(c => c.name === 'log');  
    if(!logChannel) return;  
 
    let messageDelete = new Discord.RichEmbed()  
    .setTitle('**[MESSAGE DELETE]**')  
    .setColor('RED')  
    .setThumbnail(message.author.avatarURL)  
    .setDescription(`**\n**:wastebasket: Successfully \`\`DELETE\`\` **MESSAGE** In ${message.channel}\n\n**Channel:** \`\`${message.channel.name}\`\` (ID: ${message.channel.id})\n**Message ID:** ${message.id}\n**Sent By:** <@${message.author.id}> (ID: ${message.author.id})\n**Message:**\n\`\`\`${message}\`\`\``)
    .setTimestamp()  
    .setFooter(message.guild.name, message.guild.iconURL)  
 
    logChannel.send(messageDelete);
});

client.on('messageUpdate', (oldMessage, newMessage) => {  
 
    if(oldMessage.author.bot) return;
    if(!oldMessage.channel.type === 'dm') return;
    if(!oldMessage.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!oldMessage.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;
 
    var logChannel = oldMessage.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(oldMessage.content.startsWith('https://')) return;  
 
    let messageUpdate = new Discord.RichEmbed()
    .setTitle('**[MESSAGE EDIT]**')
    .setThumbnail(oldMessage.author.avatarURL)
    .setColor('BLUE')
    .setDescription(`**\n**:wrench: Successfully \`\`EDIT\`\` **MESSAGE** In ${oldMessage.channel}\n\n**Channel:** \`\`${oldMessage.channel.name}\`\` (ID: ${oldMessage.channel.id})\n**Message ID:** ${oldMessage.id}\n**Sent By:** <@${oldMessage.author.id}> (ID: ${oldMessage.author.id})\n\n**Old Message:**\`\`\`${oldMessage}\`\`\`\n**New Message:**\`\`\`${newMessage}\`\`\``)
    .setTimestamp()
    .setFooter(oldMessage.guild.name, oldMessage.guild.iconURL)
 
    logChannel.send(messageUpdate);
});
 
 

client.on('roleCreate', role => {
 
    if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = role.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    role.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let roleCreate = new Discord.RichEmbed()
        .setTitle('**[ROLE CREATE]**')
        .setThumbnail(userAvatar)  
        .setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('GREEN')
        .setTimestamp()
        .setFooter(role.guild.name, role.guild.iconURL)  
   
        logChannel.send(roleCreate);
    })
});
client.on('roleDelete', role => {  
 
    if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = role.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    role.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let roleDelete = new Discord.RichEmbed()
        .setTitle('**[ROLE DELETE]**')
        .setThumbnail(userAvatar)  
        .setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('RED')
        .setTimestamp()  
        .setFooter(role.guild.name, role.guild.iconURL)
 
        logChannel.send(roleDelete);  
    })
});
client.on('roleUpdate', (oldRole, newRole) => {
 
    if(!oldRole.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!oldRole.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = oldRole.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
   
    oldRole.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
   
        if(oldRole.name !== newRole.name) {
            let roleUpdateName = new Discord.RichEmbed()
            .setTitle('**[ROLE NAME UPDATE]**')  
            .setThumbnail(userAvatar)  
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` Role Name.\n\n**Old Name:** \`\`${oldRole.name}\`\`\n**New Name:** \`\`${newRole.name}\`\`\n**Role ID:** ${oldRole.id}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldRole.guild.name, oldRole.guild.iconURL)
 
            logChannel.send(roleUpdateName);  
        }
        if(oldRole.hexColor !== newRole.hexColor) {  
            if(oldRole.hexColor === '#000000') {  
                var oldColor = '`Default`';  
            }else {
                var oldColor = oldRole.hexColor;
            }    
            if(newRole.hexColor === '#000000') {  
                var newColor = '`Default`';  
            }else {
                var newColor = newRole.hexColor;  
            }  
            let roleUpdateColor = new Discord.RichEmbed()  
            .setTitle('**[ROLE COLOR UPDATE]**')  
            .setThumbnail(userAvatar)  
            .setColor('BLUE')  
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` **${oldRole.name}** Role Color.\n\n**Old Color:** ${oldColor}\n**New Color:** ${newColor}\n**Role ID:** ${oldRole.id}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()  
            .setFooter(oldRole.guild.name, oldRole.guild.iconURL)
   
            logChannel.send(roleUpdateColor);
        }
        if(oldRole.permissions !== newRole.permissions) {  
            let roleUpdate = new Discord.RichEmbed()  
            .setTitle('**[UPDATE ROLE PERMISSIONS]**')  
            .setThumbnail(userAvatar)  
            .setColor('BLUE')
            .setDescription(`**\n**:first_place: Successfully \`\`CHANGED\`\` **${oldRole.name}** Permissions!\n\n**Old Permissions:** \`\`${oldRole.permissions}\`\`\n**New Permissions:** \`\`${newRole.permissions}\`\`\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldRole.guild.name, oldRole.guild.iconURL)
           
            logChannel.send(roleUpdate) 
        }
    })
});
 
 

client.on('channelCreate', channel => { 
  
    if(!channel.guild) return;
    if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = channel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(channel.type === 'text') {
        var roomType = 'Text';
    }else
    if(channel.type === 'voice') { 
        var roomType = 'Voice';
    }else
    if(channel.type === 'category') { 
        var roomType = 'Category';
    }
 
    channel.guild.fetchAuditLogs().then(logs => { 
        var userID = logs.entries.first().executor.id; 
        var userAvatar = logs.entries.first().executor.avatarURL;
   
        let channelCreate = new Discord.RichEmbed() 
        .setTitle('**[CHANNEL CREATE]**') 
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('GREEN')
        .setTimestamp()
        .setFooter(channel.guild.name, channel.guild.iconURL)
 
        logChannel.send(channelCreate);
    })
}); 
client.on('channelDelete', channel => { 
    if(!channel.guild) return;
    if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = channel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return; 
 
    if(channel.type === 'text') { 
        var roomType = 'Text';
    }else
    if(channel.type === 'voice') { 
        var roomType = 'Voice';
    }else
    if(channel.type === 'category') { 
        var roomType = 'Category';
    }
 
    channel.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let channelDelete = new Discord.RichEmbed()
        .setTitle('**[CHANNEL DELETE]**')
        .setThumbnail(userAvatar) 
        .setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('RED')
        .setTimestamp()
        .setFooter(channel.guild.name, channel.guild.iconURL)
 
        logChannel.send(channelDelete); 
    })
});
client.on('channelUpdate', (oldChannel, newChannel) => {
    if(!oldChannel.guild) return;
 
    var logChannel = oldChannel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(oldChannel.type === 'text') {
        var channelType = 'Text';
    }else
    if(oldChannel.type === 'voice') {
        var channelType = 'Voice';
    }else
    if(oldChannel.type === 'category') {
        var channelType = 'Category';
    }
   
    oldChannel.guild.fetchAuditLogs().then(logs => { 
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;

        if(oldChannel.name !== newChannel.name) {
            let newName = new Discord.RichEmbed()
            .setTitle('**[CHANNEL EDIT]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Name\n\n**Old Name:** \`\`${oldChannel.name}\`\`\n**New Name:** \`\`${newChannel.name}\`\`\n**Channel ID:** ${oldChannel.id}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp() 
            .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL) 
 
            logChannel.send(newName); 
        }
        if(oldChannel.topic !== newChannel.topic) { 
            let newTopic = new Discord.RichEmbed() 
            .setTitle('**[CHANNEL EDIT]**') 
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Topic\n\n**Old Topic:**\n\`\`\`${oldChannel.topic || 'NULL'}\`\`\`\n**New Topic:**\n\`\`\`${newChannel.topic || 'NULL'}\`\`\`\n**Channel:** ${oldChannel} (ID: ${oldChannel.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL)
 
            logChannel.send(newTopic);
        }
    })
});
 
 

client.on('guildBanAdd', (guild, user) => {
 
    if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = guild.channels.find(c => c.name === 'log'); 
    if(!logChannel) return; 
 
    guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(userID === client.user.id) return;
 
        let banInfo = new Discord.RichEmbed()
        .setTitle('**[BANNED]**')
        .setThumbnail(userAvatar)
        .setColor('DARK_RED')
        .setDescription(`**\n**:airplane: Successfully \`\`BANNED\`\` **${user.username}** From the server!\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setTimestamp()
        .setFooter(guild.name, guild.iconURL)
 
        logChannel.send(banInfo);
    })
});
client.on('guildBanRemove', (guild, user) => {
    if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return; 
    if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = guild.channels.find(c => c.name === 'log'); 
    if(!logChannel) return;
 
    guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let unBanInfo = new Discord.RichEmbed()
        .setTitle('**[UNBANNED]**')
        .setThumbnail(userAvatar)
        .setColor('GREEN')
        .setDescription(`**\n**:unlock: Successfully \`\`UNBANNED\`\` **${user.username}** From the server\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setTimestamp()
        .setFooter(guild.name, guild.iconURL)
 
        logChannel.send(unBanInfo);
    })
});
client.on('guildMemberUpdate', (oldMember, newMember) => { 
    var logChannel = oldMember.guild.channels.find(c => c.name === 'log'); 
    if(!logChannel) return;
 
    oldMember.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id; 
        var userAvatar = logs.entries.first().executor.avatarURL;
        var userTag = logs.entries.first().executor.tag;
 
        if(oldMember.nickname !== newMember.nickname) {
            if(oldMember.nickname === null) {
                var oldNM = '\`\`ÿßÿ≥ŸÖŸá ÿßŸÑÿßÿµŸÑŸä\`\`';
            }else {
                var oldNM = oldMember.nickname;
            }
            if(newMember.nickname === null) {
                var newNM = '\`\`ÿßÿ≥ŸÖŸá ÿßŸÑÿßÿµŸÑŸä\`\`'; 
            }else {
                var newNM = newMember.nickname;
            }
 
            let updateNickname = new Discord.RichEmbed()
            .setTitle('**[UPDATE MEMBER NICKNAME]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:spy: Successfully \`\`CHANGE\`\` Member Nickname.\n\n**User:** ${oldMember} (ID: ${oldMember.id})\n**Old Nickname:** ${oldNM}\n**New Nickname:** ${newNM}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldMember.guild.name, oldMember.guild.iconURL)
  
            logChannel.send(updateNickname);
        }
        if(oldMember.roles.size < newMember.roles.size) {
            let role = newMember.roles.filter(r => !oldMember.roles.has(r.id)).first();
 
            let roleAdded = new Discord.RichEmbed()
            .setTitle('**[ADDED ROLE TO MEMBER]**') 
            .setThumbnail(oldMember.guild.iconURL)
            .setColor('GREEN')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`ADDED\`\` Role to **${oldMember.user.username}**\n\n**User:** <@${oldMember.id}> (ID: ${oldMember.user.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar) 
 
            logChannel.send(roleAdded);
        }
        if(oldMember.roles.size > newMember.roles.size) {
            let role = oldMember.roles.filter(r => !newMember.roles.has(r.id)).first();
 
            let roleRemoved = new Discord.RichEmbed()
            .setTitle('**[REMOVED ROLE FROM MEMBER]**')
            .setThumbnail(oldMember.guild.iconURL)
            .setColor('RED')
            .setDescription(`**\n**:negative_squared_cross_mark: Successfully \`\`REMOVED\`\` Role from **${oldMember.user.username}**\n\n**User:** <@${oldMember.user.id}> (ID: ${oldMember.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar) 
 
            logChannel.send(roleRemoved);
        }
    })
    if(oldMember.guild.owner.user.id !== newMember.guild.owner.user.id) {
        let newOwner = new Discord.RichEmbed()
        .setTitle('**[UPDATE GUILD OWNER]**')
        .setThumbnail(oldMember.guild.iconURL)
        .setColor('GREEN')
        .setDescription(`**\n**:white_check_mark: Successfully \`\`TRANSFER\`\` The Owner Ship.\n\n**Old Owner:** <@${oldMember.user.id}> (ID: ${oldMember.user.id})\n**New Owner:** <@${newMember.user.id}> (ID: ${newMember.user.id})`)
        .setTimestamp()
        .setFooter(oldMember.guild.name, oldMember.guild.iconURL)
 
        logChannel.send(newOwner);
    }
});
client.on('guildMemberAdd', member => {
  var logChannel = member.guild.channels.find(c => c.name === 'log'); 
  if(!logChannel) return;
  
  let newMember = new Discord.RichEmbed()
  .setTitle('**[NEW MEMBER ADDED]**') 
  .setThumbnail(member.user.avatarURL)
  .setColor('GREEN')
  .setDescription(`**\n**:arrow_lower_right: Joined **${member.user.username}** To the server!\n\n**User:** <@${member.user.id}> (ID: ${member.user.id})\n**Days In Discord:** ${Days(member.user.createdAt)}`)
  .setTimestamp()
  .setFooter(member.user.tag, member.user.avatarURL)
 
  logChannel.send(newMember);
});
function Days(date) {
    let now = new Date();
    let diff = now.getTime() - date.getTime();
    let days = Math.floor(diff / 86400000);
    return days + (days == 1 ? " day" : " days") + " ago";
}
client.on('guildMemberRemove', member => { 
  var logChannel = member.guild.channels.find(c => c.name === 'log'); 
  if(!logChannel) return; 
 
  let leaveMember = new Discord.RichEmbed()
  .setTitle('**[LEAVE MEMBER]**')
  .setThumbnail(member.user.avatarURL)
  .setColor('GREEN')
  .setDescription(`**\n**:arrow_upper_left: Leave **${member.user.username}** From the server.\n\n**User:** <@${member.user.id}> (ID: ${member.user.id})`)  
  .setTimestamp() 
  .setFooter(member.user.tag, member.user.avatarURL)
  
  logChannel.send(leaveMember);
});
 
 

client.on('voiceStateUpdate', (voiceOld, voiceNew) => {
 
    if(!voiceOld.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!voiceOld.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = voiceOld.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    voiceOld.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userTag = logs.entries.first().executor.tag;
        var userAvatar = logs.entries.first().executor.avatarURL;
 

        if(voiceOld.serverMute === false && voiceNew.serverMute === true) {
            let serverMutev = new Discord.RichEmbed()
            .setTitle('**[VOICE MUTE]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/pWQaw076OHwVIFZyeFoLXvweo0T_fDz6U5C9RBlw_fQ/https/cdn.pg.sa/UosmjqDNgS.png')
            .setColor('RED')
            .setDescription(`**User:** <@${voiceOld.user.id}> (ID: ${voiceOld.user.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverMutev);
        }

        if(voiceOld.serverMute === true && voiceNew.serverMute === false) {
            let serverUnmutev = new Discord.RichEmbed()
            .setTitle('**[VOICE UNMUTE]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/u2JNOTOc1IVJGEb1uCKRdQHXIj5-r8aHa3tSap6SjqM/https/cdn.pg.sa/Iy4t8H4T7n.png')
            .setColor('GREEN')
            .setDescription(`**User:** <@${voiceOld.user.id}> (ID: ${voiceOld.user.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverUnmutev);
        }

        if(voiceOld.serverDeaf === false && voiceNew.serverDeaf === true) {
            let serverDeafv = new Discord.RichEmbed()
            .setTitle('**[VOICE DEAFEN]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/7ENt2ldbD-3L3wRoDBhKHb9FfImkjFxYR6DbLYRjhjA/https/cdn.pg.sa/auWd5b95AV.png')
            .setColor('RED')
            .setDescription(`**User:** <@${voiceOld.user.id}> (ID: ${voiceOld.user.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverDeafv);
        }

        if(voiceOld.serverDeaf === true && voiceNew.serverDeaf === false) {
            let serverUndeafv = new Discord.RichEmbed() 
            .setTitle('**[VOICE UNDEAFEN]**')
            .setThumbnail('https://images-ext-2.discordapp.net/external/s_abcfAlNdxl3uYVXnA2evSKBTpU6Ou3oimkejx3fiQ/https/cdn.pg.sa/i7fC8qnbRF.png')
            .setColor('GREEN')
            .setDescription(`**User:** <@${voiceOld.user.id}> (ID: ${voiceOld.user.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverUndeafv); 
        }
    })

    if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && !voiceOld.voiceChannel) {
        let voiceJoin = new Discord.RichEmbed()
        .setTitle('**[JOIN VOICE ROOM]**')
        .setColor('GREEN')
        .setThumbnail(voiceOld.user.avatarURL)
        .setDescription(`**\n**:arrow_lower_right: Successfully \`\`JOIN\`\` To Voice Channel.\n\n**Channel:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
        .setTimestamp()
        .setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)
 
        logChannel.send(voiceJoin);
    }

    if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && !voiceNew.voiceChannel) {
        let voiceLeave = new Discord.RichEmbed()
        .setTitle('**[LEAVE VOICE ROOM]**')
        .setColor('GREEN')
        .setThumbnail(voiceOld.user.avatarURL)
        .setDescription(`**\n**:arrow_upper_left: Successfully \`\`LEAVE\`\` From Voice Channel.\n\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
        .setTimestamp()
        .setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)
 
        logChannel.send(voiceLeave); 
    }

    if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && voiceNew.voiceChannel && voiceOld.voiceChannel != null) {
        let voiceLeave = new Discord.RichEmbed()
        .setTitle('**[CHANGED VOICE ROOM]**')
        .setColor('GREEN')
        .setThumbnail(voiceOld.user.avatarURL)
        .setDescription(`**\n**:repeat: Successfully \`\`CHANGED\`\` The Voice Channel.\n\n**From:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**To:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
        .setTimestamp()
        .setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)
 
        logChannel.send(voiceLeave);
    }  
}); 



client.on('message',function(message) {
	let prefix = "-";
let args = message.content.split(" ").slice(1).join(" ");
if(message.content.startsWith(prefix + "say")) {
if(!args) return;
message.channel.send(`**# ${args}**`);
}
});

client.on('message', message => {
    if (message.content.startsWith("-hack")) {
        if(!message.author.id === '') return;
      if (message.author.bot) return
           message.delete();
             let args = message.content.split(' ').slice(1);
 
                   let virusname = args.join(' ');
                 if (virusname < 1) {
                     return message.channel.send("**```ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑŸä ÿ™ÿ®Ÿä Ÿäÿ™ŸáŸÉÿ±```**");
                 }
                 message.channel.send({embed: new Discord.RichEmbed().setTitle('Loading ' + virusname + "...").setColor(0xFF0000)}).then(function(m) {
             setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì ] 1%').setColor(0xFF0000)})
             }, 1000)
             setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì ] 2%').setColor(0xFF0000)})
             }, 2000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì ] 3%').setColor(0xFF0000)})
             }, 3000)
             setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì ] 4%').setColor(0xFF0000)})
             }, 4000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 20%').setColor(0xFF0000)})
             }, 5000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 30%').setColor(0xFF0000)})
             }, 6000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 40%').setColor(0xFF0000)})
             }, 7000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 50%').setColor(0xFF0000)})
             }, 8000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 70%').setColor(0xFF0000)})
             }, 9000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 85%').setColor(0xFF0000)})
             }, 10000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 90%').setColor(0xFF0000)})
             }, 11000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 95%').setColor(0xFF0000)})
             }, 12000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 96%').setColor(0xFF0000)})
             }, 13000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 97%').setColor(0xFF0000)})
             }, 14000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì] 98%').setColor(0xFF0000)})
             }, 15000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ] 99%').setColor(0xFF0000)})
             }, 16000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Loading Discord Virus [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì] 100%').setColor(0xFF0000)})
             }, 17000)
             setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']:' + virusname + 'done it\'s going good 100.9%').setColor(0xFF0000)})
             }, 18000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Ÿäÿ™ŸÖ ÿ™ŸáŸÉŸäÿ± ').setColor(0xFF0000)})
             }, 19000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: ÿ™ÿ≠ÿØŸäÿ´ ÿ®ÿ≥Ÿäÿ∑' + virusname + ".key").setColor(0xFF0000)})
             }, 22000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Ÿäÿ±ÿ¨Ÿâ ÿßŸÜÿ™ÿ∂ÿßÿ± ÿ´ŸàÿßŸÜŸä 5...').setColor(0xFF0000)})
             }, 25000)
               setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Ÿäÿ±ÿ¨Ÿâ ÿßŸÜÿ™ÿ∂ÿßÿ± ÿ´ŸàÿßŸÜŸä 4...').setColor(0xFF0000)})
             }, 26000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Ÿäÿ±ÿ¨Ÿâ ÿßŸÜÿ™ÿ∂ÿßÿ± ÿ´ŸàÿßŸÜŸä 3...').setColor(0xFF0000)})
             }, 27000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Ÿäÿ±ÿ¨Ÿâ ÿßŸÜÿ™ÿ∂ÿßÿ± ÿ´ŸàÿßŸÜŸä 2...').setColor(0xFF0000)})
             }, 28000)
                setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: Ÿäÿ±ÿ¨Ÿâ ÿßŸÜÿ™ÿ∂ÿßÿ± ÿ´ŸàÿßŸÜŸä 1...').setColor(0xFF0000)})
             }, 29000)
             setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì] 99%').setColor(0xFF0000)})
           }, 30000)
              setTimeout(function() {
               m.edit({embed: new Discord.RichEmbed().setTitle('[' + virusname + ']: ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì]100% virus added').setColor(0xFF0000)})
           }, 31000)
              setTimeout(function() {
               m.delete()
           }, 32000)
             setTimeout(function() {
               message.channel.send('** ! ÿ™ŸÖÿ™ ÿπŸÖŸÑŸäŸá ÿßŸÑÿ™ŸáŸÉŸäÿ± ÿ®ŸÜÿ¨ÿßÿ≠ **')
           }, 33000)
           });
         }
})




client.on('message', message =>{
    let args = message.content.split(' ');
    let prefix = '-'; 
    
    if(args[0] === `-{prefix}avatar`){
        let mentions = message.mentions.members.first()
        if(!mentions) {
          let sicon = message.author.avatarURL
          let embed = new Discord.RichEmbed()
          .setImage(message.author.avatarURL)
          .setColor("#f7abab") 
          .setDescription(`**${message.author.username}#${message.author.discriminator}**'s avatar :`);
          message.channel.send({embed})
        } else {
          let sicon = mentions.user.avatarURL
          let embed = new Discord.RichEmbed()
          .setColor("#f7abab")
          .setDescription(`**${mentions.user.username}#${mentions.user.discriminator}**'s avatar :`)
          .setImage(sicon)
          message.channel.send({embed})
        }
    };
});




client.on('message' , message => {
  var prefix = "-"
  
  if (message.author.bot) return;
  if (message.content.startsWith(prefix + "contact")) {
  if (!message.channel.guild) return;  
  
  
  
  let args = message.content.split(" ").slice(1).join(" ");
  
  
  
  client.users.get("337647196235366401").send(
      "\n" + "**" + "‚óè ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :" + "**" +
      "\n" + "**" + "¬ª " + message.guild.name + "**" +
      "\n" + "**" + " ‚óè ÿßŸÑŸÖÿ±ÿ≥ŸÑ : " + "**" +
      "\n" + "**" + "¬ª " + message.author.tag + "**" +
      "\n" + "**" + " ‚óè ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© : " + "**" +
      "\n" + "**" + args + "**")
  
  let embed = new Discord.RichEmbed()
       .setAuthor(message.author.username, message.author.avatarURL)
       .setDescription('üì¨ ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸâ ÿµÿßÿ≠ÿ® ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÜÿ¨ÿßÿ≠')
       .setThumbnail(message.author.avatarURL)
       .setFooter("ScriptBot | System")
                                                  
  
  message.channel.send(embed);
  
  
  }
      
  });










client.on('message', message => { 
                                if(!message.channel.guild) return;
                        if (message.content.startsWith(prefix + 'ping')) {
                            if(!message.channel.guild) return;
                            var msg = `${Date.now() - message.createdTimestamp}`
                            var api = `${Math.round(client.ping)}`
                            if (message.author.bot) return;
                        let embed = new Discord.RichEmbed()
                        .setAuthor(message.author.username,message.author.avatarURL)
                        .setColor('#5016f3')
                        .addField('**Time Taken:**',msg + " ms :signal_strength: ")
                        .addField('**WebSocket:**',api + " ms :signal_strength: ")
                        .setTimestamp()
        message.channel.send({embed:embed});
                        }
                    });

client.on("guildMemberAdd", member => {
  member.createDM().then(function (channel) {
  return channel.send(`:rose:  ŸàŸÑŸÉŸÖ ŸÜŸàÿ±ÿ™ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:rose: 
:crown:ÿßÿ≥ŸÖ ÿßŸÑÿπÿ∂Ÿà  ${member}:crown:  
ÿßŸÜÿ™ ÿßŸÑÿπÿ∂Ÿà ÿ±ŸÇŸÖ ${member.guild.memberCount} `) 
}).catch(console.error)
})

	client.on('message', message => {
    if(message.content.includes('discord.gg/')) {
        if(message.member.hasPermission('ADMINISTRATOR')) return;
        message.delete();
        message.guild.member(message.author).addRole(message.guild.roles.find(r => r.name === 'Muted'));
        let embedP = new Discord.RichEmbed()
        .setTitle('‚ùå | ÿ™ŸÖÿ™ ŸÖÿπÿßŸÇÿ®ÿ™ŸÉ')
        .setAuthor(message.author.username, message.author.avatarURL)
        .addField(`** ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ŸÖÿÆÿßŸÑŸÅÿ© ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ŸÖŸÜ ÿÆŸÑÿßŸÑ ŸÜÿ¥ÿ± ÿ±Ÿàÿßÿ®ÿ∑ ÿßÿ∂ÿßŸÅÿ© ÿßŸÑŸâ ÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™ ÿßÿÆÿ±Ÿâ  **` , `**ŸÖŸÑÿßÿ≠ÿ∏ÿ©  : ÿ•ŸÜ ŸÉÿ¢ŸÜ Ÿáÿ∞ÿ¢ ÿßŸÑÿßÿ≥ŸÉÿßÿ™ ÿπŸÜ ÿ∑ÿ±ŸäŸÇ ÿßŸÑÿÆÿ∑ÿ£ ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™Ÿàÿ¨Ÿá ŸàÿßŸÑÿ™ŸÉŸÑŸÖ ŸÖÿπ ÿßŸÑÿßÿØÿ¢ÿ±ÿ©**`)
        .addField(`by`,`LegendSystem. `)
        .setColor('RED')
        .setThumbnail(message.author.avatarURL)
        .setFooter(`${message.guild.name} Server`, message.guild.iconURL)
        
        message.channel.send(embedP);
    }
});



client.on('message', message => {
var prefix = "-";
       if(message.content === prefix + "lock") {
                           if(!message.channel.guild) return message.reply('** This command only for servers**');

   if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply(' **__ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿßÿ™__**');
              message.channel.overwritePermissions(message.guild.id, {
            SEND_MESSAGES: false

              }).then(() => {
                  message.reply("**__ÿ™ŸÖ ÿ™ŸÇŸÅŸäŸÑ ÿßŸÑÿ¥ÿßÿ™__ ‚úÖ **")
              });
                }

    if(message.content === prefix + "unlock") {
                        if(!message.channel.guild) return message.reply('** This command only for servers**');

   if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('**__ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿßÿ™__**');
              message.channel.overwritePermissions(message.guild.id, {
            SEND_MESSAGES: true

              }).then(() => {
                  message.reply("**__ÿ™ŸÖ ŸÅÿ™ÿ≠ ÿßŸÑÿ¥ÿßÿ™__‚úÖ**")
              });
    }
       
});

client.on('message', message => {
    if (message.content.startsWith("-bot")) {
    message.channel.send({
        embed: new Discord.RichEmbed()
            .setAuthor(client.user.username,client.user.avatarURL)
            .setThumbnail(client.user.avatarURL)
            .setColor('RANDOM')
            .setTitle('Info WESO.Bot.')
            .addField('``My Ping``' , [`${Date.now() - message.createdTimestamp}` + 'MS'], true)
            .addField('``RAM Usage``', `[${(process.memoryUsage().rss / 1048576).toFixed()}MB]`, true)
            .addField('``servers``', [client.guilds.size], true)
            .addField('``channels``' , `[ ${client.channels.size} ]` , true)
            .addField('``Users``' ,`[ ${client.users.size} ]` , true)
            .addField('``My Name``' , `[ ${client.user.tag} ]` , true)
            .addField('``My ID``' , `[ ${client.user.id} ]` , true)
                  .addField('``My Prefix``' , `[ - ]` , true)
                  .addField('``My Language``' , `[ Java Script ]` , true)
    })
}
});

client.on("message", message => {
    const prefix = "-"
              
          if(!message.channel.guild) return;
   if(message.author.bot) return;
      if(message.content === prefix + "savatar"){
          const embed = new Discord.RichEmbed()
  
      .setTitle(`ServerAvatar${message.guild.name} **  `)
  .setAuthor(message.author.username, message.guild.iconrURL)
    .setColor(0x164fe3)
    .setImage(message.guild.iconURL)
    .setURL(message.guild.iconrURL)
                    .setTimestamp()

   message.channel.send({embed});
      }
  });


client.on('message', message => {
    if(message.content == '-members') {
    const embed = new Discord.RichEmbed()
    .setDescription(`**ÿ≠ÿßŸÑÿßÿ™ ÿßŸÑÿßÿπÿ∂ÿßÿ°üîã
:green_heart: ÿßŸàŸÜŸÑÿßŸäŸÜ   ${message.guild.members.filter(m=>m.presence.status == 'online').size}
:heart:ŸÖÿ¥ÿ∫ŸàŸÑ       ${message.guild.members.filter(m=>m.presence.status == 'dnd').size}
:yellow_heart: ÿÆÿßŸÖŸÑ      ${message.guild.members.filter(m=>m.presence.status == 'idle').size}   
:black_heart: ÿßŸàŸÅŸÑÿßŸäŸÜ   ${message.guild.members.filter(m=>m.presence.status == 'offline').size} 
:blue_heart:   ÿßŸÑŸÉŸÑ  ${message.guild.memberCount}**`)         
         message.channel.send({embed});

    }
  });

client.on('message',message =>   {
  if(message.channel.type == 'dm') return;
  if(message.content.startsWith(prefix + "talk")) {
      var attentions = {};
      attentions[message.guild.id] = { };
      message.channel.send( message.author + ', **Wait , PuP System**').then( (m) =>{
      m.edit( message.author + ', **ÿ£ÿ±ÿ≥ŸÑ ÿ£ŸäÿØŸä ÿßŸÑÿ±ŸàŸÖ**' )
      m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 600000 } ).then ( (m1) => {
      m1 = m1.first();
      attentions[message.guild.id]['id'] = m1.content;
      m1.delete();
m1 = message.guild.channels.get(`${attentions[message.guild.id]['id']}`)
if(!m1) return message.reply(`**ÿßŸÑÿ£ŸäÿØŸä Ÿáÿ∞ÿß ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ \`${attentions[message.guild.id]['id']}\`**`);
 
      m.edit(message.author+"**ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑŸá ÿßŸÑŸÖÿ±ÿßÿØ ÿ™Ÿàÿ¨ŸäŸáŸáÿß ŸÑŸÑÿ±ŸàŸÖ**")
      m.channel.awaitMessages( m2 => m2.author == message.author,{ maxMatches: 1, time: 600000 }).then ( (m2) => {
      m2 = m2.first();
      attentions[message.guild.id]['msg'] = m2.content;
      m2.delete();
      m.delete();
      message.channel.send(`**ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÅŸä ÿ±ŸàŸÖ <#${attentions[message.guild.id]['id']}>
${attentions[message.guild.id]['msg']}**`).then(msge => {
      msge.react('‚úÖ').then( r => {
      msge.react('‚ùå')
      const oneFilterBB = (reaction, user) => reaction.emoji.name === '‚úÖ' && user.id === message.author.id;
      const threeFilterBB = (reaction, user) => reaction.emoji.name === '‚ùå' && user.id === message.author.id;
      const oneBY = msge.createReactionCollector(oneFilterBB, {maxMatches : 1,time : 400000,});
      const threeBY = msge.createReactionCollector(threeFilterBB, {maxMatches : 1,time : 400000,});
      oneBY.on('collect', r => {
      msge.delete();
      message.guild.channels.get(`${attentions[message.guild.id]['id']}`).send(`${attentions[message.guild.id]['msg']}`)
      }).catch(RebeL =>{ console.log('`Error`: ' + RebeL)});
          threeBY.on('collect', r => {
      msge.delete();
      })
      })
  })
      });
      });
      });
     
    }
    });




client.on('message', function(msg) {
  if(msg.content.startsWith ('-server')) {
    if(!msg.channel.guild) return msg.reply('**:x: ÿßÿ≥ŸÅ ŸÑŸÉŸÜ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± ŸÑŸÑÿßÿØÿßÿ±Ÿá ŸÅŸÇÿ∑**');         
    let embed = new Discord.RichEmbed()
    .setColor('RANDOM')
    .setThumbnail(msg.guild.iconURL)
    .addField(':globe_with_meridians: **ÿßÿ≥ŸÖ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± : **' , `**[ ${msg.guild.name} ]**`,true)
    .addField(':earth_africa: ** ŸÖŸàŸÇÿπ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :**',`**[ ${msg.guild.region} ]**`,true)
    .addField(':military_medal:** ÿßŸÑÿ±ÿ™ÿ® :**',`**[ ${msg.guild.roles.size} ]**`,true)
    .addField(':bust_in_silhouette:** ÿπÿØÿØ ÿßŸÑÿßÿπÿ∂ÿßÿ° :**',`**[ ${msg.guild.memberCount} ]**`,true)
    .addField(':white_check_mark:** ÿπÿØÿØ ÿßŸÑÿßÿπÿ∂ÿßÿ° ÿßŸÑÿßŸàŸÜŸÑÿßŸäŸÜ :**',`**[ ${msg.guild.members.filter(m=>m.presence.status == 'online').size} ]**`,true)
    .addField(':pencil:** ÿßŸÑÿ±ŸàŸÖÿßÿ™ ÿßŸÑŸÉÿ™ÿßÿ®Ÿäÿ© :**',`**[ ${msg.guild.channels.filter(m => m.type === 'text').size} ]**`,true)
    .addField(':loud_sound:** ÿ±ŸàŸÖÿßÿ™ ÿßŸÑÿµŸàÿ™ :**',`**[ ${msg.guild.channels.filter(m => m.type === 'voice').size} ]**`,true)
    .addField(':crown:** ÿµÿßÿ≠ÿ® ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :**',`**[ ${msg.guild.owner} ]**`,true)
    .addField(':id:** ÿßŸäÿØŸä ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :**',`**[ ${msg.guild.id} ]**`,true)
    .addField(':date:** ÿ™ŸÖ ÿπŸÖŸÑ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ŸÅŸä : **',msg.guild.createdAt.toLocaleString())
    msg.channel.send({embed:embed});
  }
});

 
client.on('message', message => {
    if (!message.content.startsWith(prefix)) return;
  if(!message.channel.guild) return message.reply('** This command only for servers **')
    let command = message.content.split(" ")[0];
    command = command.slice(prefix.length);
    if (command === "kill"){

   var sabotage = message.mentions.users.first();
   if(sabotage == message.author)return message.reply(`**ÿßŸÑÿßŸÜÿ™ÿ≠ÿßÿ± ŸÖŸà ÿ≤ŸäŸÜ Ÿà ÿßŸÑŸÑŸá**`);
    if(sabotage === client.user) return message.reply(`** ÿ™ÿ®Ÿä ÿ™ŸÇÿ™ŸÑŸÜŸä ÿü **`);
  if (sabotage < 1) {
    message.delete();
    return message.channel.sendMessage('ÿ∂ÿπ ÿ¥Ÿäÿ¶ÿß ŸÑŸÑŸÇÿ™ŸÑÿå ŸÖÿ´ŸÑ ÿ∞ŸÉÿ± ŸÖÿ≥ÿ™ÿÆÿØŸÖÿå ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ±ŸÖÿ≤ ÿ™ÿπÿ®Ÿäÿ±Ÿä');
  }
  if (!sabotage) return message.channel.send(`Please Mention A Member to Kill :warning:`)
  message.channel.send("‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä ${sabotage")
  .then(msg =>{
  msg.edit(`‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä ${sabotage} :three:`);
  setTimeout(function() {
    msg.edit(`‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä ${sabotage} :two:`);
  }, 1000);
  setTimeout(function() {
    msg.edit(`‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä ${sabotage} :one:`);
  }, 2000);
  setTimeout(function() {
    msg.edit(`‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä :boom:`);
  }, 3000);
  setTimeout(function() {
    msg.edit(`‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä :fire:`);
  }, 4000);
  setTimeout(function() {
    msg.edit(`‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä :skull:`);
  }, 5000);
  msg.delete(6000)
  message.delete()
  })
  message.channel.send("**ÿ™ŸÖ ÿßÿÆŸÅÿßÿ° ÿßŸÑÿ¨ÿ±ŸäŸÖÿ© ÿ®ŸÜÿ¨ÿßÿ≠ üï≥ **").then(msg => msg.delete(7000));
    }
});




client.on('message', message => {
              if (!message.channel.guild) return;
      if(message.content =='-count')
      var IzRo = new Discord.RichEmbed()
      .setThumbnail(message.author.avatarURL)
      .setFooter(message.author.username, message.author.avatarURL)
      .setTitle('üåç| Members info')
      .addBlankField(true)
      .addField('Mmeber Count',`${message.guild.memberCount}`)
      message.channel.send(IzRo);
    });

client.on('message', msg => {
  if (msg.author.bot) return;
  if (!msg.content.startsWith(prefix)) return;
  let command = msg.content.split(" ")[0];
  command = command.slice(prefix.length);
  let args = msg.content.split(" ").slice(1);

    if(command === "ŸÖÿ≥ÿ≥ÿ≠") {
        const emoji = client.emojis.find("name", "wastebasket")
    let textxt = args.slice(0).join("");
    if(msg.member.hasPermission("MANAGE_MESSAGES")) {
    if (textxt == "") {
        msg.delete().then
    msg.channel.send("***```ÿ∂ÿπ ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ŸÖÿ≥ÿ≠Ÿáÿß üëå```***").then(m => m.delete(3000));
} else {
    msg.delete().then
    msg.delete().then
    msg.channel.bulkDelete(textxt);
        msg.channel.send("```php\nÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™Ÿä ÿ™ŸÖ ŸÖÿ≥ÿ≠Ÿáÿß: " + textxt + "\n```").then(m => m.delete(3000));
        }    
    }
}
});

client.on('message', message => {
    if (message.content === "-rooms") {
        var channels = message.guild.channels.map(channels => `${channels.name}, `).join(' ')
        const embed = new Discord.RichEmbed()
        .setColor('RANDOM')
        .addField('rooms:',`**[${channels}]**`)
        message.channel.sendEmbed(embed);
    }
});

client.on('message',async message => {
  var time = moment().format('Do MMMM YYYY , hh:mm');
  var room;
  var title;
  var duration;
  var gMembers;
  var currentTime = new Date(),
hours = currentTime.getHours() + 3 ,
minutes = currentTime.getMinutes(),
done = currentTime.getMinutes() + duration / 60000 ,
seconds = currentTime.getSeconds();
if (minutes < 10) {
minutes = "0" + minutes;
}
var suffix = "AM";
if (hours >= 12) {
suffix = "PM";
hours = hours - 12;
}
if (hours == 0) {
hours = 12;
}
 
  var filter = m => m.author.id === message.author.id;
  if(message.content.startsWith(prefix + "giveaway")) {
 
    if(!message.guild.member(message.author).hasPermission('MANAGE_GUILD')) return message.channel.send(':heavy_multiplication_x:| **Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸÑÿØŸäŸÉ ÿÆÿßÿµŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿπŸÑŸâ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±**');
    message.channel.send(`:eight_pointed_black_star:| **ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ ÿßŸÑŸÄ ÿ±ŸàŸÖ **`).then(msg => {
      message.channel.awaitMessages(filter, {
        max: 1,
        time: 20000,
        errors: ['time']
      }).then(collected => {
        let room = message.guild.channels.find('name' , collected.first().content);
        if(!room) return message.channel.send(':heavy_multiplication_x:| **i Found It :(**');
        room = collected.first().content;
        collected.first().delete();
        msg.edit(':eight_pointed_black_star:| **ŸÉŸÖ ÿ™ÿ±ŸäÿØ ÿßŸÑŸÄŸàŸÇÿ™ **').then(msg => {
          message.channel.awaitMessages(filter, {
            max: 1,
            time: 20000,
            errors: ['time']
          }).then(collected => {
            if(isNaN(collected.first().content)) return message.channel.send(':heavy_multiplication_x:| **ÿßŸÜÿß ŸÑŸÖ ÿßŸÅŸáŸÖ Ÿáÿßÿ∞ÿß ÿßŸÑŸàŸÇÿ™**');
            duration = collected.first().content * 60000;
            collected.first().delete();
            msg.edit(':eight_pointed_black_star:| **ŸÖÿß ŸáŸä ÿßŸÑÿ¨ÿßÿ¶ÿ≤ÿ©ÿü**').then(msg => {
              message.channel.awaitMessages(filter, {
                max: 1,
                time: 20000,
                errors: ['time']
              }).then(collected => {
                title = collected.first().content;
                collected.first().delete();
                msg.delete();
                message.delete();
                try {
                  let giveEmbed = new Discord.RichEmbed()
                  .setDescription(`**${title}** \nReact With üéâ To Enter! \nTime remaining : ${duration / 60000} **Minutes**\n **Created at :** ${hours}:${minutes}:${seconds} ${suffix}`)
                  .setFooter(message.author.username, message.author.avatarURL);
                  message.guild.channels.find("name" , room).send(' :heavy_check_mark: **The Giveaway was created** :heavy_check_mark:' , {embed: giveEmbed}).then(m => {
                     let re = m.react('üéâ');
                     setTimeout(() => {
                       let users = m.reactions.get("üéâ").users;
                       let list = users.array().filter(u => u.id !== m.author.id !== client.user.id);
                       let gFilter = list[Math.floor(Math.random() * list.length) + 0]
                       let endEmbed = new Discord.RichEmbed()
                       .setAuthor(message.author.username, message.author.avatarURL)
                       .setTitle(title)
                       .addField('Giveaway Ended !üéâ',`Winners : ${gFilter} \nEnded at :`)
                       .setTimestamp()
                     m.edit('** üéâ GIVEAWAY ENDED üéâ**' , {embed: endEmbed});
                    message.guild.channels.find("name" , room).send(`**Congratulations ${gFilter}! You won on the Giveaway \`${title}\`**` , {embed: {}})
                     },duration);
                   });
                } catch(e) {
                message.channel.send(`:heavy_multiplication_x:| **ŸÑŸäÿ≥ÿ™ ŸÑÿØŸä ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑŸÉÿßŸÅŸäÿ©**`);
                 console.log(e);
               }
             });
           });
         });
       });
     });
   });
 }
});


 client.on('message', message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);
if (command == "za5") {
    let say = new Discord.RichEmbed()
    .setTitle('Text emboss :');
  message.reply(`\n ${zalgo(args.join(' '))}`);
  }

});

client.on('guildCreate', guild => {
  var embed = new Discord.RichEmbed()
  .setColor(0x5500ff)
  .setDescription(`**ÿ¥ŸÉÿ±ÿßŸã ŸÑŸÉ ŸÑÿ•ÿ∂ÿßŸÅŸá ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑŸâ ÿ≥Ÿäÿ±ŸÅÿ±ŸÉ**`)
      guild.owner.send(embed)
});
  
const devs = ["436938949588549634", "596443880413593613"]
 
const adminprefix = "-";
client.on('message', message => {
    var argresult = message.content.split(` `).slice(1).join(' ');
      if (!devs.includes(message.author.id)) return;
     
  if (message.content.startsWith(adminprefix + 'pt')) {
    client.user.setGame(argresult);
      message.channel.sendMessage(`**:white_check_mark:   ${argresult}**`)
  } else
    if (message.content === (adminprefix + "Percie")) {
    message.guild.leave();        
  } else
  if (message.content.startsWith(adminprefix + 'wt')) {
  client.user.setActivity(argresult, {type:'WATCHING'});
      message.channel.sendMessage(`**:white_check_mark:   ${argresult}**`)
  } else
  if (message.content.startsWith(adminprefix + 'setprefix')) {
  client.user.setPrefix(argresult).then
      message.channel.send(`**Prefix Changed :white_check_mark: ${argresult}** `)
  } else
  if (message.content.startsWith(adminprefix + 'ls')) {
  client.user.setActivity(argresult , {type:'LISTENING'});
      message.channel.sendMessage(`**:white_check_mark:   ${argresult}**`)
  } else
    if (message.content.startsWith(adminprefix + 'setname')) {
  client.user.setUsername(argresult).then
      message.channel.sendMessage(`**${argresult}** : Done `)
  return message.reply("**Name Changed :white_check_mark:**");
  } else
    if (message.content.startsWith(adminprefix + 'setavatar')) {
  client.user.setAvatar(argresult);
    message.channel.sendMessage(`**${argresult}** : ÿ™ŸÖ ÿ™ÿ∫Ÿäÿ± ÿµŸàÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™`);
        } else    
  if (message.content.startsWith(adminprefix + 'st')) {
    client.user.setGame(argresult, "https://www.twitch.tv/idk");
      message.channel.sendMessage(`**:white_check_mark:   ${argresult}**`)
    }
 
  });



 
client.on('message', message => {
  if (message.author.x5bz) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "kick") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("KICK_MEMBERS")) return message.reply("**You Don't Have ` KICK_MEMBERS ` Permission**");
  if(!message.guild.member(client.user).hasPermission("KICK_MEMBERS")) return message.reply("**I Don't Have ` KICK_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  let reason = message.content.split(" ").slice(2).join(" ");
  if (message.mentions.users.size < 1) return message.reply("**ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ**");
  if(!reason) return message.reply ("**ÿßŸÉÿ™ÿ® ÿ≥ÿ®ÿ® ÿßŸÑÿ∑ÿ±ÿØ**");
  if (!message.guild.member(user)
  .kickable) return message.reply("**ŸÑÿß ŸäŸÖŸÉŸÜ ÿ∑ÿ±ÿØ ÿ¥ÿÆÿµ ÿ®ÿ±ÿ™ÿ®ÿ© ÿπŸÑŸäÿß !**");

  message.guild.member(user).kick();

  const kickembed = new Discord.RichEmbed()
  .setAuthor(`KICKED!`, user.displayAvatarURL)
  .setColor("RANDOM")
  .setTimestamp()
  .addField("**User:**",  '**[ ' + `${user.tag}` + ' ]**')
  .addField("**By:**", '**[ ' + `${message.author.tag}` + ' ]**')
  .addField("**Reason:**", '**[ ' + `${reason}` + ' ]**')
  message.channel.send({
    embed : kickembed
  })
}
});

const badwords = require('./badwords.json');
client.on("message", message => {
    if(message.author.bot) return;
    if(message.channel.type === "dm") return;
    if(badwords.some(word => message.content.includes(word))) {
    let warn = message.guild.roles.find('name', 'warn') || message.guild.roles.get(r => r.name === 'warn');
    if(!warn) { 
        message.guild.createRole({name: 'warn'}).then(
        message.guild.channels.forEach(chan => 
        chan.overwritePermissions(warn, {
            SEND_MESSAGES:true,
            ADD_REACTIONS:false
        })))}
    let Muted = message.guild.roles.find('name', 'Muted') || message.guild.roles.get(r => r.name === 'Muted');
    if(!Muted) {
        message.guild.createRole({name: 'Muted'}).then(
        message.guild.channels.forEach(c => 
        c.overwritePermissions(Muted, {
            SEND_MESSAGES:false,
            ADD_REACTIONS:false
        })))}

    if(message.member.roles.some(role => role.name === 'warn')) {
    message.reply(`üîá ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ¶ŸÉ ŸÖŸäŸàÿ™ ŸÑŸÖÿØÿ© ÿ≥ÿßÿπÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸÉ ŸÉŸÑŸÖÿßÿ™ ÿ∫Ÿäÿ± ŸÑÿßÿ¶ŸÇÿ©`);
    message.member.addRole(Muted);
    setTimeout(() => {    
    message.member.removeRole(Muted);
}, 3600000)//ŸÑÿ™ÿ∫Ÿäÿ± ŸÖÿØÿ© ŸÑŸÖŸäŸàÿ™
}

    else{
    
    message.reply(`‚ö†Ô∏è  ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ¶ŸÉ ÿßŸÜÿ∞ÿßÿ± ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸÉ ŸÉŸÑŸÖÿßÿ™ ÿ≥Ÿäÿ¶ÿ©`);
    }
    
}
})

client.on('message',message =>{
  var command = message.content.toLowerCase().split(" ")[0];
    var args = message.content.toLowerCase().split(" ");
    var userM = message.mentions.users.first()
    if(command == prefix + 'unban') {
        if(!message.member.hasPermission('BAN_MEMBERS')) return message.channel.send(':no_entry: | You dont have **BAN_MEMBERS** Permission!');
        if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.channel.send(':no_entry: | I dont have **BAN_MEMBERS** Permission!');
        if(!args[1]) return  message.channel.send(':information_source:  `#kick <@id>` Ÿäÿ¨ÿ® ÿ™ÿ≠ÿØŸäÿØ ÿ¥ÿÆÿµ');
        if(args[1].length < 16) return message.reply(':no_entry: | This ID is not id user!');
        message.guild.fetchBans().then(bans => {
            var Found = bans.find(m => m.id === args[1]);
            if(!Found) return message.channel.send(`:no_entry: | <@${message.author.id}> This preson not have any ban from this server! :unlock:`);
            message.guild.unban(args[1]);
            message.channel.send(`:white_check_mark: Successfully \`\`UNBANNED\`\` <@${args[1]}> From the server!`);
            }

        )}
      })

client.on('message', message => {
  if (message.author.codes) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "-ban") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**ÿßŸÜÿ™ ŸÑÿß ÿ™ŸÖŸÑŸÉ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®Ÿá**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  
  if (message.mentions.users.size < 1) return message.reply("**ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ**");
  if (!message.guild.member(user)
  .bannable) return message.reply("**Ÿäÿ¨ÿ® ÿßŸÜ ÿ™ŸÉŸàŸÜ ÿ±ÿ™ÿ®ÿ© ÿßŸÑÿ®Ÿàÿ™ ÿßÿπŸÑŸä ŸÖŸÜ ÿ±ÿ™ÿ®Ÿá ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑŸÖÿ±ÿßÿØ ÿ™ÿ®ŸÜŸäÿØÿ©**");


  message.guild.member(user).ban(7, user);

message.channel.send(`**:white_check_mark: ${user.tag} banned from the server ! :airplane: **  `)

}
});

client.on('message', message => {
  if (message.author.x5bz) return;

  let command = message.content.split(" ")[0];

  let args = message.content.split(" ").slice(1);

  if (command == "üëû") {
    if (!message.channel.guild) return;
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**You Don't Have ` BAN_MEMBERS ` Permission**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  let reason = message.content.split(" ").slice(2).join(" ");
  /*let b5bzlog = client.channels.find("name", "5bz-log");

  if(!b5bzlog) return message.reply("I've detected that this server doesn't have a 5bz-log text channel.");*/
  if (message.mentions.users.size < 1) return message.reply("**Mention User**");
  if(!reason) return;
  if (!message.guild.member(user)
  .bannable) return message.reply("**This person has a grade higher than his bot rank**");

  message.guild.member(user).ban(7, user);
  message.channel.send(`**:white_check_mark: ${user} has been banned :airplane: **`)
user.send(`You Are Has Been Banned Permanently In ${message.guild.name} reason: ${reason}`)
  }})

      client.on('message', async message => {
        let banembed = new Discord.RichEmbed()
        .setImage('https://i.top4top.io/p_1567kuqf31.png')
        var moment = require('moment');
        var mmss = require('ms')
        let date = moment().format('Do MMMM YYYY , hh:mm');
        let User = message.mentions.users.first();
        let Reason = message.content.split(" ").slice(3).join(" ");
        let messageArray = message.content.split(" ");
        let time = messageArray[2];
        if(message.content.startsWith(prefix + "ban")) {
           if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.channel.send("**You dont have ban_members permission :/ **");
           if(!User) return message.channel.sendEmbed(banembed)
           if(User.id === client.user.id) return message.channel.send("**Why you want to ban me ? :/**");
           if(User.id === message.guild.owner.id) return message.channel.send("**Nice try man :> you cant ban the ownership**");
           if(!time) return message.channel.send("**- ÿßŸÉÿ™ÿ® ÿßŸÑŸàŸÇÿ™**");
           if(!time.match(/[1-60][s,m,h,d,w]/g)) return message.channel.send('**- Error in this Duration**');
           if(!Reason) message.channel.send("**- ÿßŸÉÿ™ÿ® Reason**");
      message.channel.send(`**:white_check_mark: ${User} has been banned :airplane: **`).then(() => message.guild.member(User).ban({reason: Reason}))
      User.send(`**:airplane: You are has been banned in ${message.guild.name} reason: ${Reason} by: ${message.author.tag} :airplane:**`)
           .then(() => { setTimeout(() => {
               message.guild.unban(User);
           }, mmss(time));
        });
       }
      });

client.on('message', message => {
            var prefix = "-";
    if (message.author.bot) return;
    if (!message.content.startsWith(prefix)) return;

    let command = message.content.split(" ")[0];
    command = command.slice(prefix.length);

    let args = message.content.split(" ").slice(1);

    if (command == "embed") {
        if (!message.channel.guild) return message.reply('** This command only for servers **');
        let say = new Discord.RichEmbed()
            .addField('Emebad:', `${message.author.username}#${message.author.discriminator}`)
            .setDescription(args.join("  "))
            .setColor(0x23b2d6)
        message.channel.sendEmbed(say);
        message.delete();
    }
});



client.on('message', message => {
if (message.content.startsWith(prefix+"ct")) {
    var args = message.content.split(" ").slice(1);
    var argrst = args.join(' ');
                message.guild.createChannel(`${argrst}`, 'text')
      }
});

client.on('message', message => {
if (message.content.startsWith(prefix+"cv")) {
    var args = message.content.split(" ").slice(1);
    var argrst = args.join(' ');
                message.guild.createChannel(`${argrst}`,'voice')
         
        }
});

const perfix = '$';
client.on('message', msg => {
 if (msg.content.startsWith(prefix + 'send')) {
      let args = msg.content.split(' ').slice(1)
      if (!args[0]) return msg.reply(`**ŸÖŸÜÿ¥ŸÜ ÿßŸÑÿ¥ÿÆÿµ ÿßŸàŸÑÿß**`)
      if (!args[1]) return msg.reply(`**ŸÖÿß ŸáŸä ÿßŸÑÿ±ÿ≥ÿßŸÑŸá ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿßÿ±ÿ≥ÿßŸÑŸáÿß**`)
      let alpha = msg.mentions.members.first()
      if (!alpha) return msg.reply(`**Ÿäÿ¨ÿ® ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ¥ÿÆÿµ**`)
      let alphaEmbed = new Discord.RichEmbed()
      .setTitle(`**ÿ±ÿ≥ÿßŸÑÿ© ÿ¨ÿØŸäÿØŸá ŸÑŸÉ ŸÖŸÜ ÿ¥ÿÆÿµ ŸÖÿß**`)
      .setDescription(args.join(" "))

      client.users.get(`${alpha.id}`).send(alphaEmbed)
      msg.reply(`**ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑŸá**`)
    }
});

var cats = [

"https://static.pexels.com/photos/104827/cat-pet-animal-domestic-104827.jpeg",
"https://www.petfinder.com/wp-content/uploads/2012/11/101438745-cat-conjunctivitis-causes.jpg",
"http://www.i-love-cats.com/images/2015/04/12/cat-wallpaper-38.jpg",
"https://www.aspca.org/sites/default/files/cat-care_urine-marking_main-image.jpg",
"https://vignette1.wikia.nocookie.net/houseofnight/images/8/8b/Cats.jpg/revision/latest?cb=20130812053537",
"https://s-media-cache-ak0.pinimg.com/originals/f0/3b/76/f03b7614dfadbbe4c2e8f88b69d12e04.jpg",
"http://www.rd.com/wp-content/uploads/sites/2/2016/04/15-cat-wants-to-tell-you-attention.jpg"
]
    client.on('message', message => {
        
        var args = message.content.split(" ").slice(1);
    if(message.content.startsWith(prefix + 'cat')) {
        if(!message.channel.guild) return message.reply('** This command only for servers **');
         var cat = new Discord.RichEmbed()
.setImage(cats[Math.floor(Math.random() * cats.length)])
.setColor(0xd3d0c4)
   .setFooter(`WESO.Bot`)
message.channel.sendEmbed(cat);

    }
});

client.on('message' , message => {
    ;
    let user = message.mentions.users.first()|| client.users.get(message.content.split(' ')[1])
    if(message.content.startsWith(prefix + 'unban')) {
        if(!message.member.hasPermission('ADMINISTRATOR')) return message.channel.send('‚ùå|**\`ADMINISTRATOR\`ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÑÿØŸäŸÉ ÿ±ÿ™ÿ®ÿ©`**');
        if(!user) return  message.channel.send(`Do this ${prefix} <@ID user> \n or \n ${prefix}unban ID user`);
        message.guild.unban(user);
        message.guild.owner.send(`ŸÑŸÇÿØ ÿ™ŸÖ ŸÅŸÉ ÿßŸÑÿ®ÿßŸÜÿØ ÿπŸÜ ÿßŸÑÿ¥ÿÆÿµ \n ${user} \n By : <@${message.author.id}>`)
        var embed = new Discord.RichEmbed()
        .setThumbnail(message.author.avatarURl)
        .setColor("RANDOM")
        .setTitle('**‚óèUnban** !')
        .addField('**‚óèUser Unban :** ', `${user}` , true)
        .addField('**‚óèBy :**' ,       ` <@${message.author.id}> ` , true)
        .setAuthor(message.guild.name)
        message.channel.sendEmbed(embed)
    }
});



  
  client.on('message', message => {
       if (message.content.startsWith(prefix + 'bs')) {
     let msg =  client.guilds.map(guild => `**${guild.name}** ÿπÿØÿØ ÿßŸÑÿßÿπÿ∂ÿßÿ°: ${guild.memberCount}`).join('\n');
  let embed = new Discord.RichEmbed()
  .setTitle(`${client.guilds.size}ÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™ `)
  .setDescription(`${msg}`)
  .setColor("#ebf442");
  message.channel.send(embed);
}
});
  



   
   client.on('message', message => {
     if(!message.channel.guild) return;
var prefix = "-";
                if(message.content.startsWith(prefix + 'allbots')) {

    
    if (message.author.bot) return;
    let i = 1;
        const botssize = message.guild.members.filter(m=>m.user.bot).map(m=>`${i++} - <@${m.id}>`);
          const embed = new Discord.RichEmbed()
          .setAuthor(message.author.tag, message.author.avatarURL)
          .setDescription(`**Found ${message.guild.members.filter(m=>m.user.bot).size} bots in this Server**
${botssize.join('\n')}`)
.setFooter(client.user.username, client.user.avatarURL)
.setTimestamp();
message.channel.send(embed)

}


});
   
   client.on('message', message => {
	var prefix = "-";
    if(message.content.startsWith(prefix + 'mvall')) {
     if (!message.member.hasPermission("MOVE_MEMBERS")) return message.channel.send('**:x: You Dont Have Perms `MOVE_MEMBERS`**');
       if(!message.guild.member(client.user).hasPermission("MOVE_MEMBERS")) return message.reply("**:x: I Dont Have Perms `MOVE_MEMBERS`**");
    if (message.member.voiceChannel == null) return message.channel.send(`**You Have To Be In Room Voice**`)
     var author = message.member.voiceChannelID;
     var m = message.guild.members.filter(m=>m.voiceChannel)
     message.guild.members.filter(m=>m.voiceChannel).forEach(m => {
     m.setVoiceChannel(author)
     })
     message.channel.send(`**:white_check_mark: Success Moved All To Your Channel**`)


     }
       });
   
   
   client.on('message', msg => {
	var  prefix = "-";
 if (msg.content.startsWith(prefix + 'cal')) {
    let args = msg.content.split(" ").slice(1);
        const question = args.join(' ');
    if (args.length < 1) {
        msg.reply('Specify a equation, please.');
} else {    let answer;
    try {
        answer = math.eval(question);
    } catch (err) {
        msg.reply(`Error: ${err}`);
    }
    
    const embed = new Discord.RichEmbed()
    .addField("**Input**: ",`**${question}**`, true)
    .addField("**Output**: ",`**${answer}**`, true)
    msg.channel.send(embed)
    }
};
});
   
   

   client.on('message',async message => {
	
  if(message.content.startsWith(prefix + "ÿ™ŸÇÿØŸäŸÖ")) {
 
if(!message.channel.guild) return message.reply(' ');
 
 
  let submite = message.guild.channels.find(`name`, "ÿßŸÑÿ™ŸÇÿØŸäŸÖÿßÿ™");
 
  if(!submite) return message.channel.send("‚ùåŸÑŸÖ ÿßÿ¨ÿØ ÿßŸÑÿ±ŸàŸÖ ÿßŸÑÿÆÿßÿµ ÿ®ÿßŸÑÿ™ŸÇÿØŸäŸÖÿßÿ™");
 
    let filter = m => m.author.id === message.author.id;
 
    let thisMessage;
 
    let thisFalse;
 
    message.channel.send('üìù **| ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖŸÉ ÿßŸÑÿ£ŸÜ... ‚úè **').then(msg => {
 
 
 
    message.channel.awaitMessages(filter, {
 
      max: 1,
 
      time: 90000,
 
      errors: ['time']
 
    })
 
    .then(collected => {
 
      collected.first().delete();
 
      thisMessage = collected.first().content;
 
      let boi;
 
      msg.edit('üìú **| ŸáŸÑ ÿ≥ÿ™ÿ≠ÿ™ÿ±ŸÖ ÿßŸÑŸÇŸàÿßŸÜŸäŸÜÿü... ‚úè **').then(msg => {
 
 
 
          message.channel.awaitMessages(filter, {
 
            max: 1,
 
            time: 90000,
 
            errors: ['time']
 
          })
 
          .then(collected => {
 
            collected.first().delete();
 
            boi = collected.first().content;
 
            let boi2;
 
            msg.edit('ü§µ **| ŸÖÿß ÿßÿ≥ŸÖ ÿßÿ±ÿ™ÿ®Ÿá ÿßŸÑÿ™Ÿâ ÿ™ÿ±ŸäÿØ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸäŸáÿß ŸàŸÑŸÖÿßÿ∞ÿßÿü... ‚úè **').then(msg => {
 
 
 
              message.channel.awaitMessages(filter, {
 
                max: 1,
 
                time: 90000,
 
                errors: ['time']
 
              })
 
              .then(collected => {
 
                collected.first().delete();
 
              boi2 = collected.first().content;
 
      msg.edit('üõ° **| [ ŸáŸÑ ÿßŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ŸÇÿØŸäŸÖŸÉÿü | [ ŸÜÿπŸÖ ] ÿßŸà [ ŸÑÿß**');
 
 message.channel.awaitMessages(response => response.content === 'ŸÜÿπŸÖ' || 'ŸÑÿß' && filter,{
 
        max: 1,
 
        time: 90000,
 
        errors: ['time']
 
      })
 
      .then(collected => {
 
        if(collected.first().content === 'ŸÑÿß') {
 
          msg.delete();
 
          message.delete();
 
          thisFalse = false;
 
        }
 
        if(collected.first().content === 'ŸÜÿπŸÖ') {
 
          if(thisFalse === false) return;
 
          msg.edit('üïä **| Done ‚úÖ, ÿ™ŸÖ ÿ®ŸÜÿ¨ÿßÿ≠ ŸÜÿ¥ÿ± ÿ™ŸÇÿØŸäŸÖ ŸÅŸä ÿ±ŸàŸÖ ÿßŸÑÿ™ŸÇÿØŸäŸÖÿßÿ™**');
 
          collected.first().delete();
 
          submite.send(`@everyone | @here
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
**[ ${message.guild.name}:arrow_down: ] Submite‚¨á**
 
[**ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÇÿØŸÖ**]:
${thisMessage}
 
[**ŸáŸÑÿ≥Ÿäÿ≠ÿ™ÿ±ŸÖ ÿßŸÑŸÇŸàÿßŸÜŸäŸÜÿü**]:
${boi}
 
[**ÿßÿ≥ŸÖ ÿßŸÑÿ±ÿ™ÿ®Ÿá ŸàÿßŸÑÿ≥ÿ®ÿ®**]:
${boi2}
 
[**ÿ™ŸÖ ÿßŸÑÿ™ŸÇÿØŸäŸÖ ÿ®Ÿàÿßÿ≥ÿ∑ÿ©**]:
${message.author}
 
[**ÿßŸäÿØŸä ÿßŸÑŸÖŸÇÿØŸÖ**]:
${message.author.id}`);
 
        }
 
      }
 
  );
 
});
 
    });
 
  }
 
    );
 
  });
 
}
 
);
 
    })}});
   
   client.on('message', message => {
	var prefix = "-";
    if(message.content.startsWith(prefix + 'moveall')) {
     if (!message.member.hasPermission("MOVE_MEMBERS")) return message.channel.send('**:x: You Dont Have Perms `MOVE_MEMBERS`**');
       if(!message.guild.member(client.user).hasPermission("MOVE_MEMBERS")) return message.reply("**:x: I Dont Have Perms `MOVE_MEMBERS`**");
    if (message.member.voiceChannel == null) return message.channel.send(`**You Have To Be In Room Voice**`)
     var author = message.member.voiceChannelID;
     var m = message.guild.members.filter(m=>m.voiceChannel)
     message.guild.members.filter(m=>m.voiceChannel).forEach(m => {
     m.setVoiceChannel(author)
     })
     message.channel.send(`**:white_check_mark: Success Moved All To Your Channel**`)


     }
       });
   
   client.on('message', message => {
    if (message.content.startsWith(prefix + 'roles')) {
 
        const Rank = message.guild.roles.map(e => e.toString()).join(" ");
 
        const RankList = new Discord.RichEmbed()
            .setTitle('‚û† Roles.')
            .setAuthor(message.guild.name, message.guild.iconURL)
            .setColor('RANDOM')
            .setDescription(Rank)
            .setFooter(message.guild.name)
        message.channel.send(RankList)
    }
});
   
client.on('message', message => {
	var prefix = "-";
if(!message.channel.guild) return;
if(message.content.startsWith(prefix + 'move')) {
 if (message.member.hasPermission("MOVE_MEMBERS")) {
 if (message.mentions.users.size === 0) {
 return message.channel.send("``Use : " +prefix+ "move @User``")
}
if (message.member.voiceChannel != null) {
 if (message.mentions.members.first().voiceChannel != null) {
 var authorchannel = message.member.voiceChannelID;
 var usermentioned = message.mentions.members.first().id;
var embed = new Discord.RichEmbed()
 .setTitle("Succes!")
 .setColor("#000000")
 .setDescription(`‚úÖ You Have Moved <@${usermentioned}> To Your Channel`)
var embed = new Discord.RichEmbed()
.setTitle(`You are Moved in ${message.guild.name}`)
 .setColor("RANDOM")
.setDescription(`**<@${message.author.id}> Moved You To His Channel!\nServer --> ${message.guild.name}**`)
 message.guild.members.get(usermentioned).setVoiceChannel(authorchannel).then(m => message.channel.send(embed))
message.guild.members.get(usermentioned).send(embed)
} else {
message.channel.send("`You Cant Move"+ message.mentions.members.first() +" `The User Should Be In channel To Move It`")
}
} else {
 message.channel.send("**``You Should Be In Room Voice To Move SomeOne``**")
}
} else {
message.react("‚ùå")
 }}});
  
  
  
  client.on('message',async message => {
  let args = message.content.split(" ").slice(1).join(" ");
  let role = message.guild.roles.find('name',args) || message.guild.roles.get(args);


  if(message.content.startsWith(prefix + "gRole")) {
    if(!args) return message.reply('ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ ÿßŸÑÿ±ÿ™ÿ®ÿ©');
    if(!role) return message.reply('Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ™ÿ®ÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©');
    let iQp = new Discord.RichEmbed()
    .setAuthor(message.author.tag,message.author.avatarURL)
    .setTitle(message.guild.name)
    .setThumbnail(message.guild.iconURL)
    .addField('- ÿßÿ≥ŸÖ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.name,true)
    .addField('- ÿßŸä ÿØŸä ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.id,true)
    .addField('- ÿ™ŸÖ ÿßŸÜÿ¥ÿßÿ° ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.createdAt.toLocaleString(),true)
    .addField('- ŸÑŸàŸÜ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.hexColor,true)
    .addField('- ÿπÿØÿØ ÿßŸÑÿßÿπÿ∂ÿßÿ° ÿßŸÑÿ∞Ÿä ŸÑÿØŸäŸáŸÖ ŸÜŸÅÿ≥ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.members.size,true)
    .addField('- ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ±ÿ™ÿ®ÿ© ÿ®ŸäŸÜ ŸÉŸÑ ÿßŸÑÿ±ÿ™ÿ®',role.position - message.guild.roles.size,true)
    .addField('- ÿÆÿµÿßÿ¶ÿµ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.permissions,true)
    .setFooter(message.author.tag,message.author.avatarURL);

    message.channel.send(iQp);
  }
}); 
   
client.on("message", message => {
    var prefix = "-";
    const command = message.content.split(" ")[0];

    if(command == prefix+"kv"){

        if (!message.guild.member(message.author).hasPermission('MOVE_MEMBERS') || !message.guild.member(message.author).hasPermission('ADMINISTRATOR')) {
            return message.reply('you do not have permission to perform this action!');
        }

        var member = message.guild.members.get(message.mentions.users.array()[0].id);
        if(!message.mentions.users){
            message.reply("please mention the member")
            return;
        }

    if(!member.voiceChannel){
    message.reply("i can't include voice channel for member!")
    return;
    }
              message.guild.createChannel('voicekick', 'voice').then(c => {
                member.setVoiceChannel(c).then(() => {
                    c.delete(305).catch(console.log)
        


    
      });
     });
    }
});

client.on('message', message => {
	var prefix = "-";
if (message.content.startsWith(prefix + 'tag')) {
    let args = message.content.split(" ").slice(1);
if(!args[0]) return message.reply('Write Some Things');  
if(!message.member.hasPermission('ADMINISTRATOR'))
    figlet(args.join(" "), (err, data) => {
              message.channel.send("```" + data + "```")
           })
}
});
   
 

client.on("message", message => {
    if (message.content.startsWith("-obc")) {
                 if (!message.member.hasPermission("ADMINISTRATOR"))  return;
  let args = message.content.split(" ").slice(1);
  var argresult = args.join(' ');
  message.guild.members.filter(m => m.presence.status !== 'all').forEach(m => {
  m.send(`${argresult}\n ${m}`);
  })
  message.channel.send(`\`${message.guild.members.filter( m => m.presence.status !== 'all').size}\`:mailbox:  ÿπÿØÿØ ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖŸäŸÜ `);
  message.delete();
  };
  });




client.on('message', message => {    
            if (message.content.startsWith(prefix + "cto")) {
                if(!message.channel.guild) return;
                if (!message.member.hasPermission("MANAGE_CHANNEL"))  return;
      var a= message.content.split(' ').slice(1).join("  ");
      if (!a) return message.reply("ÿßŸÉÿ™ÿ® ŸÉŸÑÿßŸÖ ŸÑŸàÿ∂ÿπŸá ŸÅŸä ÿßŸÑÿ™Ÿàÿ®ŸäŸÉ!")
      message.channel.setTopic(`${a}`)
      .then(newChannel => message.channel.send(`ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ™Ÿàÿ®ŸäŸÉ ŸÑŸÄ **${a}**`))
      .catch(console.error);
            }
        });

  client.on("message", function(message) {
    var prefix = "-";
   if(message.content.startsWith(prefix + "help")) {
    let messageArgs = message.content.split(" ").slice(1).join(" ");
    let messageRPS = message.content.split(" ").slice(2).join(" ");
    let arrayRPS = ['**# - Rock**','**# - Paper**','**# - Scissors**'];
    let result = `${arrayRPS[Math.floor(Math.random() * arrayRPS.length)]}`;
    var RpsEmbed = new Discord.RichEmbed()
    .setAuthor(message.author.username)
    .setThumbnail(message.author.avatarURL)
    .addField("Puplic | ÿπÿßŸÖŸá","üë•",true)
    message.channel.send(RpsEmbed).then(msg => {
        msg.react('üë•')
.then(() => msg.react('üë•'))
let reaction1Filter = (reaction, user) => reaction.emoji.name === 'üë•' && user.id === message.author.id;
let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 20000 });  
let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 19000 });
reaction1.on("collect", r => {
  const embed = new Discord.RichEmbed()
      .setThumbnail('https://images-ext-2.discordapp.net/external/JD7xvknBVacXHoC2re78AtJN4PUY5IjUZy1uWIqzObI/https/s3.amazonaws.com/eclincher.wp.upload/wp-content/uploads/2015/08/25155834/people-icon.png')
      .setColor("#000000")
      .setDescription(`
      :busts_in_silhouette:***__ÿßŸàÿßŸÖÿ± ÿπÿßŸÖÿ©__***:loudspeaker: 
**
**
`)
   message.author.sendEmbed(embed)
      message.reply('ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑŸÉ ÿ®ŸÑÿÆÿßÿµ')
})

reaction4.on("collect", r => {
  const embed = new Discord.RichEmbed()
      .setColor("#000000")
      .setDescription(`
            -=- ÿßŸÑÿ±ŸàŸÖÿßÿ™ ÿßŸÑŸÑÿßÿ≤ŸÖÿ© ŸÑŸÑÿ®Ÿàÿ™ -=-
„Äé=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.„Äè
ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ±ŸàŸÖÿßÿ™ ÿ®ÿßŸÑÿßÿ≥ŸÖÿßÿ° ÿßŸÑÿ™ÿßŸÑŸäÿ©
Weclome ÿ±ŸàŸÖ ÿßŸÑÿ™ÿ±ÿ≠Ÿäÿ®
suggestions ÿ±ŸàŸÖ ÿßŸÑÿßŸÇÿ™ÿ±ÿßÿ≠ÿßÿ™
'ÿ±ŸàŸÖ 'ÿßŸÑÿ™ŸÇÿØŸäŸÖÿßÿ™ 
„Äé=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.„Äè
`)
   message.author.sendEmbed(embed)
})
    })
}
});



client.on('message', message => {
    if (message.content.startsWith("-avatar")) {
if(!message.channel.guild) return;
        var mentionned = message.mentions.users.first();
    var client;
      if(mentionned){
          var client = mentionned; } else {
          var client = message.author;
      }
        const embed = new Discord.RichEmbed()
                           .addField('Requested by:', "<@" + message.author.id + ">")
        .setColor(000000)
        .setImage(`${client.avatarURL}`)
      message.channel.sendEmbed(embed);
    }
});

client.on('message', message => {
    if(message.content.includes('discord.gg')){
                                            if(!message.channel.guild) return message.reply('** advertising me on DM ? ü§î   **');
        if (!message.member.hasPermissions(['ADMINISTRATOR'])){
        message.delete()
    return message.reply(`** ŸÖŸÖŸÜŸàÿπ ŸÜÿ¥ÿ± ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑ :angry: ! **`)
    }
}
});

    client.on('message',async message => {
    if(message.content.startsWith(prefix + "setbot")) {
    if(!message.guild.member(message.author).hasPermissions('MANAGE_CHANNELS')) return message.reply('‚ùå **ŸÑÿß ÿ™ŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠ŸäŸá**');
    if(!message.guild.member(client.user).hasPermissions(['MANAGE_CHANNELS','MANAGE_ROLES_OR_PERMISSIONS'])) return message.reply('‚ùå **ŸÑÿß ÿßŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠ŸäŸá**');
    message.channel.send('‚úÖ| **ÿ™ŸÖ ÿπŸÖŸÑ ÿßŸÑÿ±ŸàŸÖ ÿ®ŸÜÿ¨ÿßÿ≠**');
    message.guild.createChannel(`Bots : : [ ${message.guild.members.filter(m=>m.user.bot).size} ]` , 'voice').then(c => {
      console.log(`Done make room in: \n ${message.guild.name}`);
      c.overwritePermissions(message.guild.id, {
        CONNECT: false,
        SPEAK: false
      });
      setInterval(() => {
        c.setName(`Bots : [ ${message.guild.members.filter(m=>m.user.bot).size} ]`)
      },1000);
    });
    }
  });

client.on('message', message => { 
    if (message.content.startsWith(prefix + 'emojilist')) {

        const List = message.guild.emojis.map(e => e.toString()).join(" ");

        const EmojiList = new Discord.RichEmbed()
            .setTitle('‚û† Emojis') 
            .setAuthor(message.guild.name, message.guild.iconURL) 
            .setColor('RANDOM') 
            .setDescription(List) 
            .setFooter(message.guild.name) 
        message.channel.send(EmojiList) 
    }
});


  client.on('message', message => {
    if (message.content.startsWith("-bans")) {
        message.guild.fetchBans()
        .then(bans => message.channel.send(`${bans.size} ÿπÿØÿØ ÿßÿ¥ÿÆÿßÿµ ÿßŸÑŸÖÿ®ŸÜÿØÿ© ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± `))
  .catch(console.error);
}
});




client.on('message', message => {
  var prefix ="-";
if (message.content.startsWith(prefix + 'perms')) {
         if(!message.channel.guild) return;
         var perms = JSON.stringify(message.channel.permissionsFor(message.author).serialize(), null, 4);
         var zPeRms = new Discord.RichEmbed()
         .setColor('RANDOM')
         .setTitle(':tools: Permissions')
         .addField('Your Permissions:',perms)
                  message.channel.send({embed:zPeRms});
 
    }
});


 client.on("message", async message => {
            if(!message.channel.guild) return;
        if(message.content.startsWith(prefix + 'Minv')) {
        var nul = 0
        var guild = message.guild
        await guild.fetchInvites()
            .then(invites => {
             invites.forEach(invite => {
                if (invite.inviter === message.author) {
                     nul+=invite.uses
                    }
                });
            });
          if (nul > 0) {
              console.log(`\n${message.author.tag} has ${nul} invites in ${guild.name}\n`)
              var embed = new Discord.RichEmbed()
                  .setColor("#000000")
                    .addField(`${message.author.username}`, `ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ÿØÿπŸàÿ© **${nul}** ÿ¥ÿÆÿµ`)
                          message.channel.send({ embed: embed });
                      return;
                    } else {
                       var embed = new Discord.RichEmbed()
                        .setColor("#000000")
                        .addField(`${message.author.username}`, `ŸÑŸÖ ÿ™ŸÇŸÖ ÿ®ÿØÿπŸàÿ© ÿ£Ÿä ÿ¥ÿÆÿµ ŸÑŸáÿ∞ÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±`)

                       message.channel.send({ embed: embed });
                        return;
                    }
        }
        if(message.content.startsWith(prefix + 'invite-codes')) {
let guild = message.guild
var codes = [""]
message.channel.send(":postbox: **ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ÿ£ÿ±ÿ≥ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿ±Ÿàÿßÿ®ÿ∑ ÿßŸÑÿØÿπŸàÿßÿ™ ÿßŸÑÿ™Ÿä ŸÇŸÖÿ™ ÿ®ÿ£ŸÜÿ¥ÿßÿ¶Ÿáÿß ŸÅŸä ÿßŸÑÿÆÿßÿµ**")
guild.fetchInvites()
.then(invites => {
invites.forEach(invite => {
if (invite.inviter === message.author) {
codes.push(`discord.gg/${invite.code}`)
}
})
}).then(m => {
if (codes.length < 0) {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `You currently don't have any active invites! Please create an invite and start inviting, then you will be able to see your codes here!`)
message.author.send({ embed: embed });
return;
} else {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `Invite Codes:\n${codes.join("\n")}`)
message.author.send({ embed: embed });
return;
}
})
}

});

client.on('message' , message => {
      var prefix = "-";
      if(message.author.bot) return;
     
      if(message.content.startsWith(prefix + "bcrole")) {
        if (!message.member.hasPermission("ADMINISTRATOR"))  return;
        let args = message.content.split(" ").slice(2);
     var codes = args.join(' ')
       
        if(!codes) {
          message.channel.send("ŸÇŸÖ ÿ®ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© | `$rolebc role message`")
            return;
        }
     
     
              var role = message.mentions.roles.first();
                if(!role) {
                  message.reply("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿ™ÿ®ÿ© ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ")
                    return;
                }
            message.guild.members.filter(m => m.roles.get(role.id)).forEach(n => {
              n.send(`${codes}`)
            })
            message.channel.send(`ŸÑŸÇÿØ ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸâ ${message.guild.members.filter(m => m.roles.get(role.id)).size} ÿπÿ∂Ÿà`)
        }
    });

 client.on('message', message => {
  if(!message.channel.guild) return;
if(message.content.startsWith('-bc')) {
if(!message.channel.guild) return message.channel.send('**Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÅŸÇÿ∑ ŸÑŸÑÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™**').then(m => m.delete(5000));
if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**ŸÑŸÑÿ£ÿ≥ŸÅ ŸÑÿß ÿ™ŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ©** `ADMINISTRATOR`' );
let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
let copy = "ScrpitBot";
let request = `Requested By ${message.author.username}`;
if (!args) return message.reply('**Ÿäÿ¨ÿ® ÿπŸÑŸäŸÉ ŸÉÿ™ÿßÿ®ÿ© ŸÉŸÑŸÖÿ© ÿßŸà ÿ¨ŸÖŸÑÿ© ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™**');message.channel.send(`**ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿ±ÿ≥ÿßŸÑŸÉ ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™ÿü \nŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™:** \` ${args}\``).then(msg => {
msg.react('‚úÖ')
.then(() => msg.react('‚ùå'))
.then(() =>msg.react('‚úÖ'))

let reaction1Filter = (reaction, user) => reaction.emoji.name === '‚úÖ' && user.id === message.author.id;
let reaction2Filter = (reaction, user) => reaction.emoji.name === '‚ùå' && user.id === message.author.id;
let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
reaction1.on("collect", r => {
message.channel.send(`‚òë | Done ... The Broadcast Message Has Been Sent For ${message.guild.members.size} Members`).then(m => m.delete(5000));
message.guild.members.forEach(m => {
var bc = new
Discord.RichEmbed()
.setColor('RANDOM')
.setTitle('Broadcast')
.addField('Server', message.guild.name)
.addField('Sender', message.author.username)
.addField('Message', args)
.setThumbnail(message.author.avatarURL)
.setFooter(copy, client.user.avatarURL);
m.send({ embed: bc })
msg.delete();
})
})
reaction2.on("collect", r => {
message.channel.send(`**Broadcast Canceled.**`).then(m => m.delete(5000));
msg.delete();
})
})
}
});

client.on('message', message => {
   if(!message.channel.guild) return;
if(message.content.startsWith(prefix + 'bk')) {
if(!message.channel.guild) return message.channel.send('**Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÅŸÇÿ∑ ŸÑŸÑÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™**').then(m => m.delete(5000));
if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**ŸÑŸÑÿ£ÿ≥ŸÅ ŸÑÿß ÿ™ŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ©** `ADMINISTRATOR`' );
let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
let BcList = new Discord.RichEmbed()
.setThumbnail(message.author.avatarURL)
.setAuthor(`ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑŸá ${args}`)
.setDescription(`ÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™ ÿ®ŸÄ ÿßŸÖÿ®ÿØ üìù\nÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™ ÿ®ÿØŸàŸÜ ÿßŸÖÿ®ÿØ‚úè \nŸÑÿØŸäŸÉ ÿØŸÇŸäŸÇŸá ŸÑŸÑÿ£ÿÆÿ™Ÿäÿßÿ± ŸÇÿ®ŸÑ ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™`)
if (!args) return message.reply('**Ÿäÿ¨ÿ® ÿπŸÑŸäŸÉ ŸÉÿ™ÿßÿ®ÿ© ŸÉŸÑŸÖÿ© ÿßŸà ÔøΩÔøΩŸÖŸÑÿ© ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™**');message.channel.send(BcList).then(msg => {
msg.react('üìù')
.then(() => msg.react('‚úè'))
.then(() =>msg.react('üìù'))
 
let EmbedBcFilter = (reaction, user) => reaction.emoji.name === 'üìù' && user.id === message.author.id;
let NormalBcFilter = (reaction, user) => reaction.emoji.name === '‚úè' && user.id === message.author.id;
 
let EmbedBc = msg.createReactionCollector(EmbedBcFilter, { time: 60000 });
let NormalBc = msg.createReactionCollector(NormalBcFilter, { time: 60000 });
 
EmbedBc.on("collect", r => {
message.channel.send(`:ballot_box_with_check: ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑŸá ÿ®ŸÜÿ¨ÿßÿ≠`).then(m => m.delete(5000));
message.guild.members.forEach(m => {
var bc = new
Discord.RichEmbed()
.setColor('RANDOM')
.setDescription(`Message : ${args}`)
.setAuthor(`Server : ${message.guild.name}`)
.setFooter(`Sender : ${message.author.username}`)
.setThumbnail(message.author.avatarURL)
m.send({ embed: bc })
msg.delete();
})
})
NormalBc.on("collect", r => {
  message.channel.send(`:ballot_box_with_check: ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑŸá ÿ®ŸÜÿ¨ÿßÿ≠`).then(m => m.delete(5000));
message.guild.members.forEach(m => {
m.send(args);
msg.delete();
})
})
})
}
});
client.on('message' , message => {
      if(message.author.bot) return;
     
      if(message.content.startsWith(prefix + "rolebc")) {
        if (!message.member.hasPermission("ADMINISTRATOR"))  return;
        let args = message.content.split(" ").slice(2);
     var codes = args.join(' ')
       
        if(!codes) {
          message.channel.send("ŸÇŸÖ ÿ®ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© | !rolebc @everyone message")
            return;
        }
     
     
              var role = message.mentions.roles.first();
                if(!role) {
                  message.reply("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿ™ÿ®ÿ© ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ")
                    return;
                }
            message.guild.members.filter(m => m.roles.get(role.id)).forEach(n => {
              n.send(
              "**" + "ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :" + "\n" +
              `${message.guild.name}` + "\n" +
              "ÿßŸÑŸÖÿ±ÿ≥ŸÑ :" + "\n" +
              `${message.author.tag}` + "\n" +
              "ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© :" + "\n" +
              `${codes}` + "**"
              )
            })
            message.channel.send(`ŸÑŸÇÿØ ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸâ ${message.guild.members.filter(m => m.roles.get(role.id)).size} ÿπÿ∂Ÿà`)
        }
    });

client.on('message',message =>{
    if(message.content.startsWith(prefix + 'topinv')) {
  message.guild.fetchInvites().then(i =>{
  var invites = [];
   
  i.forEach(inv =>{
    var [invs,i]=[{},null];
     
    if(inv.maxUses){
        invs[inv.code] =+ inv.uses+"/"+inv.maxUses;
    }else{
        invs[inv.code] =+ inv.uses;
    }
        invites.push(`invite: ${inv.url} inviter: ${inv.inviter} \`${invs[inv.code]}\`;`);
   
  });
  var embed = new Discord.RichEmbed()
  .setColor("#000000")
  .setDescription(`${invites.join(`\n`)+'\n\n**By:** '+message.author}`)
  .setThumbnail("https://cdn.discordapp.com/attachments/442414506430169098/489929808244113409/JPEG_20180913_232108.jpg")
           message.channel.send({ embed: embed });
   
  });
   
    }
  });

client.on('message',async message => {
    if(message.content.startsWith(prefix + "setmember")) {
    if(!message.guild.member(message.author).hasPermissions('MANAGE_CHANNELS')) return message.reply('‚ùå **ŸÑÿß ÿ™ŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠ŸäŸá**');
    if(!message.guild.member(client.user).hasPermissions(['MANAGE_CHANNELS','MANAGE_ROLES_OR_PERMISSIONS'])) return message.reply('‚ùå **ŸÑÿß ÿßŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠ŸäŸá**');
    message.channel.send('‚úÖ| **ÿ™ŸÖ ÿπŸÖŸÑ ÿßŸÑÿ±ŸàŸÖ ÿ®ŸÜÿ¨ÿßÿ≠**');
    message.guild.createChannel(`Members : [ ${message.guild.members.size} ]` , 'voice').then(c => {
      console.log(`Done make room in: \n ${message.guild.name}`);
      c.overwritePermissions(message.guild.id, {
        CONNECT: false,
        SPEAK: false
      });
      setInterval(() => {
        c.setName(`Members : [ ${message.guild.members.size} ]`)
      },1000);
    });
    }
  });


client.on('message', msg => {
    if(msg.content.startsWith('-binv')) {
    if(msg.channel.type === 'dm') return;
const user = msg.mentions.users.first();
if(!user) return msg.channel.send('``' + '**ŸÇŸÖ ÿ®ÿ™ÿ≠ÿØŸäÿØ ÿ®Ÿàÿ™**' + '``')
if(!user.bot) return msg.reply('`ŸÖŸÜÿ¥ŸÜ ÿ®Ÿàÿ™`');
msg.channel.send(`**Bot InviteURL : ** https://discordapp.com/oauth2/authorize?client_id=${user.id}&scope=bot&permissions=384064`)
    }
});

client.on("message", message => {
    if (message.content === "-rules") {
           message.react("‚úÖ")
              message.react("‚ùå")
     const embed = new Discord.RichEmbed() 
         .setColor("#ffff00")
         .setDescription(`
  ‚óè‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‡Æú€©€û€©‡Æú‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚óè
[ ‚òÖ„Éªrules   |  ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±  ]
1) ŸÖŸÖŸÜŸàÿπ ÿßŸÑÿ≥ÿ® ŸÖÿπ ÿßŸâ ÿ≥ÿ®ÿ® 
2)ŸÖŸÖŸÜŸàÿπ ÿßŸÑÿ≠ÿØŸäÿ´ ÿπŸÜ ÿßŸÑÿØŸäŸÜ ÿßŸà ÿ≥ÿ®Ÿá ÿßŸà ŸÖŸÅÿßŸàÿ∂ÿßÿ™ ÿØŸäŸÜŸäŸá 
3)ŸÖŸÖŸÜŸàÿπ ÿßŸÑÿ™ÿ≠ÿØÿ´ ÿπŸÜ ÿßŸÑÿ≥Ÿäÿßÿ≥Ÿá  "
4)ŸÖŸÖŸÜŸàÿπ ÿßŸÑÿµŸàÿ± ÿßŸÑÿßÿ®ÿßÿ≠ŸäŸá ÿßŸà ÿßŸâ ÿ¥Ÿä ŸÖÿÆŸÑ ÿ®ÿßŸÑÿßÿØÿ® 
5)ŸÖŸÖŸÜŸàÿπ ŸÜÿ¥ÿ± ÿµŸàÿ± ŸÖŸÜ  ŸÖŸàÿßŸÇÿπ ÿßŸÑÿ™ŸàÿßÿµŸÑ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸâ  ÿ®ÿ≠ŸÇŸàŸÇ ŸÖŸÑŸÉŸäŸá
6)ŸÖŸÖŸÜŸàÿπ ÿ∑ŸÑÿ® ÿßŸÑÿ±ÿ™ÿ®Ÿá ŸàÿßŸÑÿ±ÿ™ÿ® ÿ™ŸÉŸàŸÜ ÿ®ÿßŸÑÿ™ŸÅÿßÿπŸÑ
7)ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™  ŸÅŸâ - #cmd
__

@everyone || @here
‚óè‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‡Æú€©€û€©‡Æú‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚óè
  
    `)
   
      message.author.sendEmbed(embed)
      
      }
}); 




		
        client.on('guildMemberRemove', member => {
            var embed = new Discord.RichEmbed()
            .setAuthor(member.user.username, member.user.avatarURL)
            .setThumbnail(member.user.avatarURL)
            .setTitle(`ÿßŸÑŸÑŸá ŸÖÿπÿßŸÉ ‚úã:skin-tone-1: üòî`)
            .setDescription(`ŸÖÿπ ÿßŸÑÿ≥ŸÑÿßŸÖŸá ÿ™ÿ¥ÿ±ŸÅŸÜÿß ÿ®ŸÉ ‚úã:skin-tone-1: üòî `)
            .addField('üë§   ÿ™ÿ®ŸÇŸä',`**[ ${member.guild.memberCount} ]**`,true)
            .setColor('RED')
            .setFooter(`==== ŸÜŸÄŸÄÿ™ŸÄŸÄŸÖŸÄŸÄŸÜŸÄŸÄÿ¢ ŸÑŸÄŸÄŸÉŸÄŸÄŸÖ ÿ¢ÿ≥ŸÄŸÄÿ™ŸÄŸÄŸÖŸÄŸÄŸÄÿ™ŸÄŸÄÿ¢ÿπ ====`, 'https://cdn.discordapp.com/attachments/397818254439219217/399292026782351381/shy.png')
        
        var channel =member.guild.channels.find('name', 'leave')
        if (!channel) return;
        channel.send({embed : embed});
        })

const HeRo = new Discord.Client();
client.on('message', message => {
var prefix = "-";

    if (message.content === prefix + "date") {
        if (!message.channel.guild) return message.reply('** This command only for servers **');  
        var currentTime = new Date(),
            Year = currentTime.getFullYear(),
            Month = currentTime.getMonth() + 1,
            Day = currentTime.getDate();

            var Date15= new Discord.RichEmbed()
            .setTitle("**!-[ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ]-! **")
            .setColor('RANDOM')
            .setTimestamp()
            .setDescription( ""+ Day + "-" + Month + "-" + Year + "")
             message.channel.sendEmbed(Date15);
    }
});

client.on('message', msg => {
                        let args = msg.content.split(" ").slice(1).join(" ")
if (msg.content.split(" ")[0].toLowerCase() === "-cr") {
    if(!args) return msg.channel.send('`ÿßŸÑÿ±ÿ¨ÿßÿ° ŸÉÿ™ÿßÿ®ÿ© ÿπÿØÿØ ÿßŸÑŸÑŸàÿßŸÜ ÿßŸÑŸÖÿ±ÿ¨Ÿâ ÿµŸÜÿπŸáÿß`');
             if (!msg.member.hasPermission('MANAGE_ROLES')) return;
              msg.channel.send(`** Done Colors Was Successful Created ${args}**`);
                  setInterval(function(){})
                    let count = 0;
                    let ecount = 0;
          for(let x = 1; x < `${parseInt(args)+1}`; x++){
            msg.guild.createRole({name:x,
              color: 'RANDOM'})
              }
            }
});

client.on('message', message => {
          let args = message.content.split(' ').slice(1);
   if(message.content.split(' ')[0] == '-color'){
           const embedd = new Discord.RichEmbed()
     .setFooter('Requested by '+message.author.username, message.author.avatarURL)
   .setDescription(`**There's No Color With This Number ** :x: `)
   .setColor(`ff0000`)

    if(!isNaN(args) && args.length > 0)
    

if    (!(message.guild.roles.find("name",`${args}`))) return  message.channel.sendEmbed(embedd);


       var a = message.guild.roles.find("name",`${args}`)
                if(!a)return;
const embed = new Discord.RichEmbed()
                    
     .setFooter('Requested by '+message.author.username, message.author.avatarURL)
   .setDescription(`**Color Changed To Successfully** :white_check_mark: `)
 
   .setColor(`${a.hexColor}`)
  message.channel.sendEmbed(embed);
          if (!args)return;
setInterval(function(){})
                  let count = 0;
                  let ecount = 0;
        for(let x = 1; x < 201; x++){
           
            message.member.removeRole(message.guild.roles.find("name",`${x}`))
          
            }
                message.member.addRole(message.guild.roles.find("name",`${args}`));
        
            
    }
});

client.on('message', message => {
    if (message.content.startsWith(prefix + 'sug')) {
        if (message.author.bot) return
        if (!message.guild) return message.reply('**:x: This Commands Just In Server**').then(v => {v.react('‚ùå')})
        var args =  message.content.split(' ').slice(1).join(' ')
        if (!args) return message.reply('Type You Suggestion').then(c => {c.delete(5000)})
        let Room = message.guild.channels.find(`name`, "suggestions")
        if (!Room) return message.channel.send("Can't find suggestions channel.").then(d => d.react('‚ùå'))
        let embed = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setAuthor(`Vote on ${message.author.username}'s suggestion`, message.author.avatarURL)
       .addField('**Suggestion**',`${args}`)
       .setThumbnail(message.author.avatarURL)
       .setFooter(`ID: ${message.author.id}`)
       Room.sendEmbed(embed).then(c => {
           c.react('‚úÖ').then(() =>
               c.react('‚ùå'))
           
       }).catch(e => console.error(e)
       )
   }
});


client.on('message', function(message) {
    if(message.content.startsWith(prefix + "report")) {
        let messageArgs = message.content.split(" ").slice(1).join(" ");
        let messageReason = message.content.split(" ").slice(2).join(" ");
        if(!messageReason) return message.reply("**# Specify a reason!**");
    let mUser = message.mentions.users.first();
    if(!mUser) return message.channel.send("Couldn't find user.");
    let Rembed = new Discord.RichEmbed()
    .setTitle("`New Report!`")
    .setThumbnail(message.author.avatarURL)
    .addField("**# - Reported User:**",mUser,true)
    .addField("**# - Reported User ID:**",mUser.id,true)
    .addField("**# - Reason:**",messageReason,true)
    .addField("**# - Channel:**",message.channel,true)
    .addField("**# - Time:**",message.createdAt,true)
    .setFooter("ŸÑŸà ÿßŸÜ ÿßŸÑÿßÿ®ŸÑÿßÿ∫ ŸÅŸäŸá ŸÖÿ≤ÿ≠ ÿ±ÿßÿ≠ Ÿäÿ™ÿπÿ±ÿ∂ ÿµÿßÿ≠ÿ® ÿßŸÑÿßÿ®ŸÑÿßÿ∫ ŸÑŸÇŸàÿ®ÿßÿ™")
message.channel.send(Rembed)
message.channel.send("__Are you sure you want to send this to the Server owner??__").then(msg => {
    msg.react("‚úÖ")
    msg.react("‚ùå")
.then(() => msg.react('‚ùå'))
.then(() =>msg.react('‚úÖ'))
let reaction1Filter = (reaction, user) => reaction.emoji.name === '‚úÖ' && user.id === message.author.id;
let reaction2Filter = (reaction, user) => reaction.emoji.name === '‚ùå' && user.id === message.author.id;

let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
reaction1.on("collect", r => {
    message.guild.owner.send(Rembed)
    message.reply("**# - Done! üéá**");
})
reaction2.on("collect", r => {
    message.reply("**# - Canceled!**");
})
})
}
});








client.on("message", msg => {
  let msgarray = msg.content.split(" ");
  let cmd = msgarray[0];
  let args = msgarray.slice(1);  
if(cmd === `${prefix}dm`){
  let mentions = msg.guild.member(msg.mentions.users.first() || msg.guild.members.get(args[0]));
  if(!mentions) return msg.reply("**ŸÖŸÜÿ¥ŸÜ ÿßŸÑÿπÿ∂Ÿà**").then(men => {
      men.delete(2222)
      msg.delete()
  })
  let args2 = args.join(" ").slice(22);
  if(!args2) return msg.reply("**ÿßŸÉÿ™ÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©**").then(am => {
      am.delete(2222)
      msg.delete()
  })
let emb = new Discord.RichEmbed()
.setTitle("**DM**")
.addField("**ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©**", args2)
.addField("**ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÄ**", mentions)
.addField("**ŸÖŸÜ ŸÇÿ®ŸÑ**", msg.author)
.setDescription(`**ŸáŸÑ ÿßŸÜÿ™ ŸÖÿ™ÿßŸíŸÉÿØ ÿ®ÿ±ÿ≥ÿßŸÑÿ™ŸÉÿü
‚úî | ŸÜÿπŸÖ

‚ùå | ŸÑÿß**`)
msg.channel.send(emb).then(od => {
  od.react("‚úî")
  .then(()=> od.react("‚úî"))
  .then(()=> od.react("‚ùå"))
  let reaction1Filter = (reaction, user) => reaction.emoji.name === '‚úî' && user.id === msg.author.id;
let reaction2Filter = (reaction, user) => reaction.emoji.name === '‚ùå' && user.id === msg.author.id;

let reaction1 = od.createReactionCollector(reaction1Filter, { time: 12000 });
let reaction2 = od.createReactionCollector(reaction2Filter, { time: 12000 });
reaction2.on("collect", r => {
msg.reply("**ÿ™ŸÖ ÿßŸÑÿ∫ÿßÿ° ÿ±ÿ≥ŸÑ ÿ±ÿ≥ÿßŸÑÿ™ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠**").then(cn => {
cn.delete(2222)
msg.delete()
})
od.delete(2222)
})
reaction1.on("collect", r => {
let embd = new Discord.RichEmbed()
.setTitle("**DM**")
.setDescription(`** ŸÖÿß ŸÜŸàÿπ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ? :arrow_down:
üö© | ÿßŸÖÿ®ÿØ

‚ú® | ÿ®ÿØŸàŸÜ ÿßŸÖÿ®ÿØ
**`)
msg.delete()
od.delete(2222)
msg.channel.send(embd).then(bo => {
bo.react("üö©")
.then(() => bo.react("üö©"))
.then(() => bo.react("‚ú®"))
let r1 = (reaction, user) => reaction.emoji.name === 'üö©' && user.id === msg.author.id;
let r2 = (reaction, user) => reaction.emoji.name === '‚ú®' && user.id === msg.author.id;

let rec1 = bo.createReactionCollector(r1, { time: 12000 });
let rec2 = bo.createReactionCollector(r2, { time: 12000 });
rec1.on("collect", r => {
let embde = new Discord.RichEmbed()
.setTitle("**ÿ±ÿ≥ÿßŸÑÿ©**")
.addField("**ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©**", args2)
.addField("**ŸÖŸÜ ŸÇÿ®ŸÑ**", msg.author)
bo.delete(2222)
msg.reply("**ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ‚úî**").then(op => {
  op.delete(2222)
  msg.delete()
})
mentions.send(embde)
})
rec2.on("collect", r => {
  mentions.send(args2)
  msg.reply("**ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ‚úî**").then(ede => {
      ede.delete(2222)
      bo.delete(2222)
      msg.delete()
     
  })
  })

})

}) 
})
}
})

const voiceonline = JSON.parse(fs.readFileSync("./voiceonline.json", "utf8")); 
client.on("message", async message => {
  if (voiceonline[message.guild.id] == undefined) {
    voiceonline[message.guild.id] = {
      onlineam: "off",
      allam: "off",
      voiceonline: "off",
      onlineid: "none",
      allid: "none",
      voiceonlineid: "none",
      onoff: "off"
    };
  }
  fs.writeFile("./voiceonline.json", JSON.stringify(voiceonline), function(
    err
  ) {
    if (err) throw err;
  });
  let args = message.content.split(" ");
  if (args[0] === `${prefix}set`) {
    if (args[1] === "voiceonline") {
      if (args[2] === "on") {
        voiceonline[message.guild.id].voiceonline = "on";
        fs.writeFile(
          "./voiceonline.json",
          JSON.stringify(voiceonline),
          function(err) {
            if (err) throw err;
          }
        );
        message.channel.send(`**Setup.**`).then(msg => {
          msg.edit(`**Setup..**`);
          msg.edit(`**Setup...**`);
          message.guild.createChannel("Member Count", "voice").then(chan => {
            let id = chan.id;
            voiceonline[message.guild.id].voiceonlineid = id
            fs.writeFile(
              "./voiceonline.json",
              JSON.stringify(voiceonline),
              function(err) {
                if (err) throw err;
              }
            );
          });
          msg.edit(`**${message.author.username} Done Changed It To On**`);
        });
      } else if (args[2] === "off") {
        voiceonline[message.guild.id].voiceonline = "off";
        fs.writeFile(
          "./voiceonline.json",
          JSON.stringify(voiceonline),
          function(err) {
            if (err) throw err;
          }
        );
        message.channel.send(
          `**${message.author.username} Done Changed It To Off**`
        );
      }
    } else if (args[1] === "onlineamount") {
                if (args[2] === "on") {
        voiceonline[message.guild.id].onlineam = "on";
        fs.writeFile(
          "./voiceonline.json",
          JSON.stringify(voiceonline),
          function(err) {
            if (err) throw err;
          }
        );
        message.channel.send(`**Setup.**`).then(msg => {
          msg.edit(`**Setup..**`);
          msg.edit(`**Setup...**`);
          message.guild.createChannel("Online Count", "voice").then(chan => {
            let id = chan.id;
            voiceonline[message.guild.id].onlineid = id
            fs.writeFile(
              "./voiceonline.json",
              JSON.stringify(voiceonline),
              function(err) {
                if (err) throw err;
              }
            );
          });
          msg.edit(`**${message.author.username} Done Changed It To On**`);
        });
      } else if (args[2] === "off") {
        voiceonline[message.guild.id].onlineam = "off";
        fs.writeFile(
          "./voiceonline.json",
          JSON.stringify(voiceonline),
          function(err) {
            if (err) throw err;
          }
        );
        message.channel.send(
          `**${message.author.username} Done Changed It To Off**`
        );
      }
    } else if (args[1] === "memberamount") {
           if (args[2] === "on") {
        voiceonline[message.guild.id].allam = "on";
        fs.writeFile(
          "./voiceonline.json",
          JSON.stringify(voiceonline),
          function(err) {
            if (err) throw err;
          }
        );
        message.channel.send(`**Setup.**`).then(msg => {
          msg.edit(`**Setup..**`);
          msg.edit(`**Setup...**`);
          message.guild.createChannel("Member Count", "voice").then(chan => {
            let id = chan.id;
            voiceonline[message.guild.id].allid = id
            fs.writeFile(
              "./voiceonline.json",
              JSON.stringify(voiceonline),
              function(err) {
                if (err) throw err;
              }
            );
          });
          msg.edit(`**${message.author.username} Done Changed It To On**`);
        });
      } else if (args[2] === "off") {
        voiceonline[message.guild.id].allam = "off";
        fs.writeFile(
          "./voiceonline.json",
          JSON.stringify(voiceonline),
          function(err) {
            if (err) throw err;
          }
        );
        message.channel.send(
          `**${message.author.username} Done Changed It To Off**`
        );
      }
    } else {
      message.channel.send(
        `**${message.author.username} Wrong Usage n Usages : n ${prefix}set voiceonline on/off n ${prefix}set onlineamount on/off n ${prefix}set membersamount on/off**`
      );
    }
  } else if (args[0] === "excommand") {
  }
});
 
client.on("voiceStateUpdate", (oldMember, newMember) => {
  if (!voiceonline[oldMember.guild.id].allam) {
    voiceonline[oldMember.guild.id].allam = "off";
    fs.writeFile("./voiceonline.json", JSON.stringify(voiceonline), function(
      err
    ) {
      if (err) throw err;
    });
  }
  if (voiceonline[oldMember.guild.id] == undefined) {
    voiceonline[oldMember.guild.id] = {
      onlineam: "off",
      allam: "off",
      voiceonline: "off",
      onlineid: "none",
      allid: "none",
      voiceonlineid: "none",
      onoff: "off"
    };
  }
  fs.writeFile("./voiceonline.json", JSON.stringify(voiceonline), function(
    err
  ) {
    if (err) throw err;
  });
  if (voiceonline[oldMember.guild.id].allam === "on") {
    let ch = voiceonline[oldMember.guild.id].allid;
    let channel = oldMember.guild.channels.get(ch);
    let guildid = voiceonline[oldMember.guild.id].allid;
    channel.setName(`Members Count [${oldMember.guild.memberCount}]`);
  }
  if (voiceonline[oldMember.guild.id].allam === "off") {
    return;
  }
});
 
 
 
client.on("voiceStateUpdate", (oldMember, newMember) => {
  if (!voiceonline[oldMember.guild.id].onlineam) {
    voiceonline[oldMember.guild.id].onlineam = "off";
    fs.writeFile("./voiceonline.json", JSON.stringify(voiceonline), function(
      err
    ) {
      if (err) throw err;
    });
  }
  if (voiceonline[oldMember.guild.id] == undefined) {
    voiceonline[oldMember.guild.id] = {
      onlineam: "off",
      allam: "off",
      voiceonline: "off",
      onlineid: "none",
      allid: "none",
      voiceonlineid: "none",
      onoff: "off"
    };
  }
  fs.writeFile("./voiceonline.json", JSON.stringify(voiceonline), function(
    err
  ) {
    if (err) throw err;
  });
  if (voiceonline[oldMember.guild.id].onlineam === "on") {
    let ch = voiceonline[oldMember.guild.id].onlineid;
    let channel = oldMember.guild.channels.get(ch);
    let guildid = voiceonline[oldMember.guild.id].onlineid;
     let size = oldMember.guild.members.filter(m => m.presence.status == "online").size
   let size2 = oldMember.guild.members.filter(m => m.presence.status == "dnd").size
       let size3 = oldMember.guild.members.filter(m => m.presence.status == "idle").size
       let amount = size + size2 + size3;
    channel.setName(`Online Count [${amount}]`);
  }
  if (voiceonline[oldMember.guild.id].onlineam === "off") {
    return;
  }
});
 
 
 
client.on("voiceStateUpdate", (oldMember, newMember) => {
  if (!voiceonline[oldMember.guild.id].voiceonline) {
    voiceonline[oldMember.guild.id].voiceonline = "off";
    fs.writeFile("./voiceonline.json", JSON.stringify(voiceonline), function(
      err
    ) {
      if (err) throw err;
    });
  }
  if (voiceonline[oldMember.guild.id] == undefined) {
    voiceonline[oldMember.guild.id] = {
      onlineam: "off",
      allam: "off",
      voiceonline: "off",
      onlineid: "none",
      allid: "none",
      voiceonlineid: "none",
      onoff: "off"
    };
  }
  fs.writeFile("./voiceonline.json", JSON.stringify(voiceonline), function(
    err
  ) {
    if (err) throw err;
  });
  if (voiceonline[oldMember.guild.id].voiceonline === "on") {
    let ch = voiceonline[oldMember.guild.id].voiceonlineid;
    let channel = oldMember.guild.channels.get(ch);
    const currentSize = oldMember.guild.members.filter(m => m.voiceChannel).size;
    channel.setName(`Voice Online [${currentSize}]`);
  }
  if (voiceonline[oldMember.guild.id].voiceonline === "off") {
     return;
  }
});

client.on('message', message => {
  if (message.author.bot) return;

  let args = message.content.split(" ");
  
  let command = args[0];
  
  let messagecount = args[1];
  
    if(command == prefix + "clear") {
    if(!message.member.hasPermission("MANAGE_MESSAGES")) {
		message.channel.send("Ÿäÿ¨ÿ® ÿßŸÜ ÿ™ŸÖÿ™ŸÑŸÉ ÿÆÿßÿµŸäÿ© `MANAGE_MESSAGES` ")
	} else if (!messagecount) {
		message.channel.send("**ŸÇŸÖ ÿ®ÿ•ÿØÿ±ÿßÿ¨ ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿßÿØ ÿ≠ÿ∞ŸÅŸáÿß**")
	}else {
		message.channel.bulkDelete(messagecount);
        message.channel.send("**ÿ±ÿ≥ÿßŸÑÿ© `" + messagecount + "`  ÿ™ŸÖ ÿ≠ÿ∞ŸÅ**").then(mes => 
		mes.delete(3000)
		);    
	 }
   }
});
	
let anti = JSON.parse(fs.readFileSync("./antigreff.json", "UTF8"));
let config = JSON.parse(fs.readFileSync("./config.json", "UTF8"));
client.on("message", message => {
    if (!message.channel.guild) return;
    let user = anti[message.guild.id + message.author.id]
    let num = message.content.split(" ").slice(2).join(" ");
    if (!anti[message.guild.id + message.author.id]) anti[message.guild.id + message.author.id] = {
        actions: 0
    }
    if (!config[message.guild.id]) config[message.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3,
        time: 30
    }
    if (message.content.startsWith(prefix + "settings limits")) {
 
 
        if (!message.member.hasPermission('MANAGE_GUILD')) return;
        if (message.content.startsWith(prefix + "settings limitsban")) {
            if (!num) return message.channel.send("**‚áè | ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ! **");
            if (isNaN(num)) return message.channel.send("**‚áè | ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑ ! **");
            config[message.guild.id].banLimit = num;
            message.channel.send(`**‚áè | ÿ™ŸÖ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸêŸÑŸä : ${config[message.guild.id].banLimit} **`)
        }
        if (message.content.startsWith(prefix + "settings limitskick")) {
            if (!num) return message.channel.send("**‚áè | ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ! **");
            if (isNaN(num)) return message.channel.send("**‚áè | ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑ ! **");
            config[message.guild.id].kickLimits = num;
            message.channel.send(`**‚áè | ÿ™ŸÖ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸêŸÑŸä : ${config[message.guild.id].kickLimits}**`)
        }
        if (message.content.startsWith(prefix + "settings limitsroleD")) {
            if (!num) return message.channel.send("**‚áè | ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ! **");
            if (isNaN(num)) return message.channel.send("**‚áè | ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑ ! **");
            config[message.guild.id].roleDelLimit = num;
            message.channel.send(`**‚áè | ÿ™ŸÖ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸêŸÑŸä : ${config[message.guild.id].roleDelLimit}**`)
        }
        if (message.content.startsWith(prefix + "settings limitsroleC")) {
            if (!num) return message.channel.send("**‚áè | ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ! **");
            if (isNaN(num)) return message.channel.send("**‚áè | ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑ ! **");
            config[message.guild.id].roleCrLimits = num;
            message.channel.send(`**‚áè | ÿ™ŸÖ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸêŸÑŸä : ${config[message.guild.id].roleCrLimits}**`)
        }
        if (message.content.startsWith(prefix + "settings limitschannelD")) {
            if (!num) return message.channel.send("**‚áè | ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ! **");
            if (isNaN(num)) return message.channel.send("**‚áè | ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑ ! **");
            config[message.guild.id].chaDelLimit = num;
            message.channel.send(`**‚áè | ÿ™ŸÖ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸêŸÑŸä : ${config[message.guild.id].chaDelLimit}**`)
        }
        if (message.content.startsWith(prefix + "settings limitstime")) {
            if (!num) return message.channel.send("**‚áè | ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ! **");
            if (isNaN(num)) return message.channel.send("**‚áè | ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑ ! **");
            config[message.guild.id].time = num;
            message.channel.send(`**‚áè | ÿ™ŸÖ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸêŸÑŸä : ${config[message.guild.id].time}**`)
        }
        fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
            if (e) throw e;
        });
        fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
            if (e) throw e;
        });
    }
});
client.on("channelDelete", async channel => {
    const entry1 = await channel.guild.fetchAuditLogs({
        type: 'CHANNEL_DELETE'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[channel.guild.id]) config[channel.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[channel.guild.id + entry.id]) {
        anti[channel.guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
    } else {
        anti[channel.guild.id + entry.id].actions = Math.floor(anti[channel.guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
        if (anti[channel.guild.id + entry.id].actions >= config[channel.guild.id].chaDelLimit) {
            channel.guild.members.get(entry.id).ban().catch(e => channel.guild.owner.send(`**‚áè | ${entry.username} ŸÇÿßŸÖ ÿ®ŸÖÿ≥ÿ≠ ÿßŸÑŸÉÿ´Ÿäÿ± ŸÖŸÜ ÿßŸÑÿ±ŸàŸÖÿßÿ™ **`))
            anti[channel.guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("roleDelete", async channel => {
    const entry1 = await channel.guild.fetchAuditLogs({
        type: 'ROLE_DELETE'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[channel.guild.id]) config[channel.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[channel.guild.id + entry.id]) {
        anti[channel.guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
    } else {
        anti[channel.guild.id + entry.id].actions = Math.floor(anti[channel.guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
        if (anti[channel.guild.id + entry.id].actions >= config[channel.guild.id].roleDelLimit) {
            channel.guild.members.get(entry.id).ban().catch(e => channel.guild.owner.send(`**‚áè | ${entry.username} ŸÇÿßŸÖ ÿ®ŸÖÿ≥ÿ≠ ÿßŸÑŸÉÿ´Ÿäÿ± ŸÖŸÜ ÿßŸÑÿ±ÿ™ÿ® **`))
            anti[channel.guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("roleCreate", async channel => {
    const entry1 = await channel.guild.fetchAuditLogs({
        type: 'ROLE_CREATE'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[channel.guild.id]) config[channel.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[channel.guild.id + entry.id]) {
        anti[channel.guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
    } else {
        anti[channel.guild.id + entry.id].actions = Math.floor(anti[channel.guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
        if (anti[channel.guild.id + entry.id].actions >= config[channel.guild.id].roleCrLimits) {
            channel.guild.members.get(entry.id).ban().catch(e => channel.guild.owner.send(`**‚áè | ${entry.username} ŸÇÿßŸÖ ÿ®ÿ£ŸÜÿ¥ÿßÿ° ÿßŸÑŸÉÿ´Ÿäÿ± ŸÖŸÜ ÿßŸÑÿ±ÿ™ÿ® **`))
            anti[channel.guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("guildBanAdd", async (guild, user) => {
    const entry1 = await channel.guild.fetchAuditLogs({
        type: 'MEMBER_BAN_ADD'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[guild.id]) config[guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[guild.id + entry.id]) {
        anti[guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
    } else {
        anti[guild.id + entry.id].actions = Math.floor(anti[guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
        if (anti[guild.id + entry.id].actions >= config[guild.id].banLimit) {
            channel.members.get(entry.id).ban().catch(e => channel.owner.send(`**‚áè | ${entry.username} ÿ≠ÿßŸàŸÑ ÿ≠ÿ∏ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿπÿ∂ÿßÿ° **`))
            anti[guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("guildKickAdd", async (guild, user) => {
    const entry1 = await channel.fetchAuditLogs({
        type: 'MEMBER_KICK'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[guild.id]) config[guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[guild.id + entry.id]) {
        anti[guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
    } else {
        anti[guild.id + entry.id].actions = Math.floor(anti[guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
        if (anti[guild.id + entry.id].actions >= config[guild.id].banLimit) {
            channel.members.get(entry.id).ban().catch(e => channel.owner.send(`**‚áè | ${entry.username} ÿ≠ÿßŸàŸÑ ÿ≠ÿ∏ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿπÿ∂ÿßÿ° **`))
            anti[guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("guildMemberRemove", async member => {
    const entry1 = await member.guild.fetchAuditLogs().then(audit => audit.entries.first())
    if (entry1.action === "MEMBER_KICK") {
        const entry2 = await member.guild.fetchAuditLogs({
            type: "MEMBER_KICK"
        }).then(audit => audit.entries.first())
        const entry = entry2.executor;
        if (!config[member.guild.id]) config[guild.id] = {
            banLimit: 3,
            chaDelLimit: 3,
            roleDelLimit: 3,
            kickLimits: 3,
            roleCrLimits: 3
        }
        if (!anti[member.guild.id + entry.id]) {
            anti[member.guild.id + entry.id] = {
                actions: 1
            }
            setTimeout(() => {
                anti[member.guild.id + entry.id].actions = "0"
            }, config[member.guild.id].time * 1000)
        } else {
            anti[member.guild.id + entry.id].actions = Math.floor(anti[member.guild.id + entry.id].actions + 1)
            console.log("TETS");
            setTimeout(() => {
                anti[member.guild.id + entry.id].actions = "0"
            }, config[member.guild.id].time * 1000)
            if (anti[member.guild.id + entry.id].actions >= config[member.guild.id].kickLimits) {
                member.members.get(entry.id).ban().catch(e => member.owner.send(`**‚áè | ${entry.username} ÿ≠ÿßŸàŸÑ ÿ≠ÿ∏ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿπÿ∂ÿßÿ° **`))
                anti[member.guild.id + entry.id].actions = "0"
                fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                    if (e) throw e;
                });
                fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                    if (e) throw e;
                });
            }
        }
 
        fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
            if (e) throw e;
        });
        fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
            if (e) throw e;
        });
    }
 
})





      client.on('message', async message => {
        let mention = message.mentions.members.first();
      let command = message.content.split(" ")[0];
         command = command.slice(prefix.length);
        let args = message.content.split(" ").slice(1);	 
      if(command === `unmute`) {2
        if(!message.member.hasPermission("MUTE_MEMBERS")) return message.channel.sendMessage("**You Donot HavePermission Mute_Members**").then(m => m.delete(5000));
      if(!message.guild.member(client.user).hasPermission("MUTE_MEMBERS")) return message.reply("**I donot Have Permission Mute_Members**").then(msg => msg.delete(6000))
      
        let kinggamer = message.guild.member(message.mentions.users.first()) || message.guild.members.get(args[0]);
           if(!kinggamer) return message.channel.send(':information_source:  `-unmute @xOday` Ÿäÿ¨ÿ® ÿ™ÿ≠ÿØŸäÿØ ÿ¥ÿÆÿµ ').then(msg => {
            msg.delete(3500);
            message.delete(3500); 
          });
      
        let role = message.guild.roles.find (r => r.name === "Muted");
        
        if(!role || !kinggamer.roles.has(role.id)) return message.channel.sendMessage(`**:information_source:${mention.user.username} ŸÑŸÇÿØ ÿ™ŸÖ ŸÅŸÉ ÿßŸÑŸÖŸäŸàÿ™ ÿπŸÜŸá ŸÖÿ≥ÿ®ŸÇÿß**`)
      
        await kinggamer.removeRole(role) 
        message.channel.sendMessage(`**:white_check_mark: ${mention.user.username}  Unmuted! **`);      
        return;
      
        }
      
      });

client.on('message', message => {

  var ms = require('ms')
 
  var moment = require('moment');
 
   
  if (message.author.bot) return;
 
  if (!message.content.startsWith(prefix)) return;
 
  let command = message.content.split(" ")[0];
 
  command = command.slice(prefix.length);
 
  let args = message.content.split(" ").slice(1);
 
  let messageArray = message.content.split(" ");
 
  let muteRole = message.guild.roles.find("name", "Muted");
	
  let embed = new Discord.RichEmbed()
 
 .setImage("https://h.top4top.io/p_1567zzx0h1.png")
 
  if (command == "mute") {
    
  if(!muteRole) return message.guild.createRole({ name: "Muted", permissions: [] });

  if(!message.channel.guild) return message.reply('** This command only for servers**');
          
  if(!message.guild.member(message.author).hasPermission("MUTE_MEMBERS")) return message.reply("**:x: You Don't Have ` MUTE_MEMBERS ` Permission**");
 
  if(!message.guild.member(client.user).hasPermission("MUTE_MEMBERS")) return message.reply("**:x: I Don't Have ` MUTE_MEMBERS ` Permission**");
 
  let user = message.mentions.users.first();
 
  let Reason = message.content.split(" ").slice(4).join(" ");
 
  let time = messageArray[2];
 
  if (message.mentions.users.size < 1) return message.channel.sendEmbed(embed)
   
  if (!message.guild.member(user).bannable) return message.reply("**:x:I Don't Have Permission For Mute This User**");
 
  if(!Reason)  {
 
    message.guild.member(user).addRole(muteRole);
 
  }
 
   if(!Reason && time) {
 
    message.guild.member(user).addRole(muteRole);
 
   }  
 
   if(!time) {
 
    message.guild.member(user).addRole(muteRole);
 
   }
       if(time === '0') {
    message.guild.member(user).addRole(muteRole);
   }
   if(time) {
    if(!time.match(/[1-60][s,m,h,d,w]/g))  return message.channel.send(':x: This Time Is Incorrect')

   setTimeout(() => {
 
    message.guild.member(user).removeRole(muteRole);
 
   }, ms(time));
 
   }
 
   if(time && Reason && user) {
 
    message.guild.member(user).addRole(muteRole);
 
	   
   setTimeout(() => {
 
    message.guild.member(user).removeRole(muteRole);
   
   }, ms(time));
 
   }
 
   message.channel.send(`:white_check_mark: ${user} has been muted ! :zipper_mouth:`)
 
   }
});


  let points = {}

client.on("message", message => {
	  if (!message.guild || message.author.bot) return;
      if (message.content == ".colors") {
          var fsn = require('fs-nextra');
          fs.readdir('./colors', async (err, files) => {
              var f = files[Math.floor(Math.random() * files.length)];
              var {
                  Canvas
              } = require('canvas-constructor');
              var x = 0;
              var y = 0;
              if (message.guild.roles.filter(role => !isNaN(role.name)).size <= 0) return;
              message.guild.roles.filter(role => !isNaN(role.name)).sort((b1, b2) => b1.name - b2.name).forEach(() => {
                  x += 100;
                  if (x > 100 * 12) {
                      x = 100;
                      y += 80;
                  }
              });
              var image = await fsn.readFile(`./colors/${f}`);
              var xd = new Canvas(100 * 11, y + 350) // ŸÉÿßŸÜÿ™ 250 ŸäŸÑŸä ŸáŸà ÿßŸÑÿ≠ŸäŸÜ 350
                  .addBeveledImage(image, 0, 0, 100 * 11, y + 350, 100) // ŸäŸÑŸä ŸáŸä ÿßŸÑÿ≠ŸäŸÜ 350 ŸÉÿßŸÜÿ™ 250 Ÿà ŸäŸÑŸä ŸáŸä ÿßŸÑÿ≠ŸäŸÜ 100 ŸÉÿßŸÜÿ™ 50
                  .setTextBaseline('middle')
                  .setColor('white')
                  .setTextSize(60)
                  .addText(`ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ŸÑŸàÿßŸÜ`, 375, 40);
              x = 0;
              y = 150;
              message.guild.roles.filter(role => !isNaN(role.name)).sort((b1, b2) => b1.name - b2.name).forEach(role => {
                  x += 75;
                  if (x > 100 * 10) {
                      x = 75;
                      y += 80;
                  }
                  xd
                      .setTextBaseline('middle')
                      .setTextAlign('center')
                      .setColor(role.hexColor)
                      .addBeveledRect(x, y, 60, 60, 15)
                      .setColor('white');
                  if (`${role.name}`.length > 2) {
                      xd.setTextSize(30);
                  } else if (`${role.name}`.length > 1) {
                      xd.setTextSize(40);
                  } else {
                      xd.setTextSize(50);
                  }
                  xd.addText(role.name, x + 30, y + 30);
              });
              message.channel.sendFile(xd.toBuffer());
          });
      }
  })


client.on('message', async message => {
if(!points) points = {}

	if(message.channel.type !== 'text') return;
	
	
	var command = message.content.toLowerCase().split(" ")[0];
	var args = message.content.toLowerCase().split(" ");
	var userM = message.guild.member(message.mentions.users.first() || message.guild.members.find(m => m.id == args[1]));
	  const embed  = new Discord.RichEmbed()
.setDescription(`
**ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£Ÿä ŸÜŸÇÿ∑ÿ© ÿ≠ÿ™Ÿâ ÿßŸÑÿ£ŸÜ **
** ÿ£ŸÖÿ´ŸÑÿ© ŸÑŸÑÿ£ŸàÿßŸÖÿ±: **
**:small_orange_diamond:** -points ${message.author} 1 \`ŸÑÿ™ÿ∫ŸäŸäÿ± ŸÜŸÇÿßÿ∑ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ \`
**:small_orange_diamond:** -points ${message.author} +1 \`ŸÑÿ≤ŸäÿßÿØÿ© ŸÜŸÇÿßÿ∑ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ\`
**:small_orange_diamond:** -points ${message.author} -1 \`ŸÑÿ£ÿ≤ÿßŸÑÿ© ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ \`
**:small_orange_diamond:** -points ${message.author} 0 \`ŸÑÿ™ÿµŸÅŸäÿ± ŸÜŸÇÿßÿ∑ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ \`
**:small_orange_diamond:** -points reset \`ŸÑÿ™ÿµŸÅŸäÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑\``)
.setFooter('Requested by '+message.author.username, message.author.avatarURL)
.setColor(`#e60909`)
  const error  = new Discord.RichEmbed()
.setDescription(`
**:x: | Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ£ŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠. **
** ÿ£ŸÖÿ´ŸÑÿ© ŸÑŸÑÿ£ŸàÿßŸÖÿ±: **
**:small_orange_diamond:** -points ${message.author} 1 \`ŸÑÿ™ÿ∫ŸäŸäÿ± ŸÜŸÇÿßÿ∑ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ \`
**:small_orange_diamond:** -points ${message.author} +1 \`ŸÑÿ≤ŸäÿßÿØÿ© ŸÜŸÇÿßÿ∑ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ\`
**:small_orange_diamond:** -points ${message.author} -1 \`ŸÑÿ£ÿ≤ÿßŸÑÿ© ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ \`
**:small_orange_diamond:** -points ${message.author} 0 \`ŸÑÿ™ÿµŸÅŸäÿ± ŸÜŸÇÿßÿ∑ ÿ¥ÿÆÿµ ŸÖÿπŸäŸÜ \`
**:small_orange_diamond:** -points reset \`ŸÑÿ™ÿµŸÅŸäÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑\``)
.setFooter('Requested by '+message.author.username, message.author.avatarURL)
.setColor(`#e60909`)
if(command == '-points') {
	 
		if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return message.channel.send(':no_entry: | I dont have Embed Links permission.');
		if(!args[1]) {
			if(!points) return message.channel.send(embed);
			var members = Object.values(points);
			var memb = members.filter(m => m.points >= 1);
			if(memb.length == 0) return message.channel.send(embed);
			var x = 1;
			let pointsTop = new Discord.RichEmbed()
			.setAuthor('Points:')
			.setColor('#FBFBFB')
			.setDescription(memb.sort((second, first) => first.points > second.points).slice(0, 10).map(m => `**:small_blue_diamond:** <@${m.id}> \`${m.points}\``).join('\n'))
			.setFooter(`Requested by ${message.author.username}`, message.author.avatarURL);
			message.channel.send({
				embed: pointsTop
			});
		}else if(args[1] == 'reset') {
			let pointsReset = new Discord.RichEmbed()
			.setDescription('**:white_check_mark: | ÿ™ŸÖ ÿ™ÿµŸÅŸäÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠**')
			.setFooter('Requested by '+message.author.username, message.author.avatarURL)
			if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send("You dont have Manage Server permission.");
			if(!points) return message.channel.send(pointsReset);
			var members = Object.values(points);
			var memb = members.filter(m => m.points >= 1);
			if(memb.length == 0) return message.channel.send(pointsReset);
			points = {};
			message.channel.send(pointsReset);
		}else if(userM) {
			if(!message.member.hasPermission('MANAGE_GUILD')) return  message.channel.send("You dont have Manage Server permission.");
			if(!points[userM.user.id]) points[userM.user.id] = {
				points: 0,
				id: userM.user.id
			};
			if(!args[2]) {
				if(points[userM.user.id].points == 0) return message.channel.send( `${userM.user.username} Not have any points.`);
				var userPoints = new Discord.RichEmbed()
				.setColor('#d3c325')
				.setAuthor(`${userM.user.username} have ${points[userM.user.id].points} points.`);
				message.channel.send({
					embed: userPoints
				});
			}else if(args[2] == 'reset') {
				if(points[userM.user.id].points == 0) return message.channel.send(error);
				points[userM.user.id].points = 0;
				message.channel.send(`Successfully reset ${userM.user.username} points.`);
			}else if(args[2].startsWith('+')) {
				args[2] = args[2].slice(1);
				args[2] = parseInt(Math.floor(args[2]));
				if(points[userM.user.id].points == 1000000) return message.channel.send(error);
				if(!args[2]) return message.channel.send(error);
				if(isNaN(args[2])) return message.channel.send(error);
				if(args[2] > 1000000) return message.channel.send(error);
				if(args[2] < 1) return message.channel.send(error);
				if((points[userM.user.id].points + args[2]) > 1000000) args[2] = 1000000 - points[userM.user.id].points;
				points[userM.user.id].points += args[2];
				let add = new Discord.RichEmbed()
				.setDescription(`**:small_blue_diamond:** <@${userM.id}> \`${points[userM.user.id].points}\``)
				.setAuthor('Points:')
				.setColor('#FBFBFB')
				.setFooter('Requested by' + message.author.username, message.author.avatarURL)
				message.channel.send(add);
			}else if(args[2].startsWith('-')) {
				args[2] = args[2].slice(1);
				args[2] = parseInt(Math.floor(args[2]));
				if(points[userM.user.id].points == 0) return message.channel.send(error);
				if(!args[2]) return message.channel.send(error);
				if(isNaN(args[2])) return message.channel.send(error);
				if(args[2] > 1000000) return message.channel.send(error);
				if(args[2] < 1) return message.channel.send(error);
				if((points[userM.user.id].points - args[2]) < 0) args[2] = points[userM.user.id].points;
				points[userM.user.id].points -= args[2];
					let rem = new Discord.RichEmbed()
				.setDescription(`**:small_blue_diamond:** <@${userM.id}> \`${points[userM.user.id].points}\``)
				.setAuthor('Points:')
				.setColor('#FBFBFB')
				.setFooter('Requested by' + message.author.username, message.author.avatarURL)
				message.channel.send(rem);
			}else if(!args[2].startsWith('+') || !args[2].startsWith('-')) {
				args[2] = parseInt(Math.floor(args[2]));
				if(isNaN(args[2])) return message.channel.send(error);
				if(args[2] > 1000000) return message.channel.send(error);
				if(args[2] < 1) return message.channel.send(error);
				if(points[userM.user.id].points == args[2]) return message.channel.send(`${userM.user.username} points is already ${args[2]}.`);
				points[userM.user.id].points = args[2];
					let set = new Discord.RichEmbed()
				.setDescription(`**:small_blue_diamond:** <@${userM.id}> \`${points[userM.user.id].points}\``)
				.setAuthor('Points:')
				.setColor('#FBFBFB')
				.setFooter('Requested by' + message.author.username, message.author.avatarURL)
				message.channel.send(set);
			}
			}
			}
  
});

client.on('message',  async  message  =>  {
    var  user  =  message.mentions.users.first();
    var  reason  =  message.content.split(' ').slice(2).join(' ');
if(message.content.startsWith(prefix  +  'warn'))  {
    if(!message.member.hasPermission('MUTE_MEMBERS')) return message.channel.send('**Sorry But You Dont Have Permission** `MUTE_MEMBERS`' );
    if(!user)  return  message.channel.send("**Command: warn** - **Warns a member.**  ```Usage:  #warn [user] [reason]```")
    if(!reason)  return  message.channel.send("** Type The Reason**")

    message.channel.send(`**__${user} Has Been Warned __**`)

 
}})

client.on('message', message => {
    if(message.content.startsWith(prefix + 'welcome')) {
      let embed = new Discord.RichEmbed()
      .setTitle('Welcome Commands :') 
      .setDescription(`${prefix}setWelcomer | To Set The Welcome
      üîπ ${prefix}setLeave | To Set The Leave Message..etc
      üîπ ${prefix}toggleLeave | To Turn Off & On The Leave Message [if you do setleave it will turned on automaticly] 
      üîπ ${prefix}toggleWelcome | To Turn Off & On The Welcome[if you do setleave it will turned on automaticly]
      üîπ ${prefix}toggleDmwelcome | To Turn Off & On The Dm Welcome Message
      üîπ  ${prefix}toggleInvitedby | To Turn Off & On Invited By Message`)
      message.channel.sendEmbed(embed)
    }
        })
const welcome = JSON.parse(fs.readFileSync('./welcomer.json' , 'utf8'));
client.on('message', async message => {
    let messageArray = message.content.split(" ");
   if(message.content.startsWith(prefix + "setLeave")) {
             
    let filter = m => m.author.id === message.author.id;
    let thisMessage;
    let thisFalse;

    if(!message.member.hasPermission("MANAGE_GUILD")) return message.channel.send('You don\'t have permission').then(msg => {
       msg.delete(4500);
       message.delete(4500);
    });
    
    message.channel.send(':pencil: **| ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßŸÉÿ™ÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑŸá ÿßŸÑÿßŸÜ... :pencil2: **').then(msg => {

        message.channel.awaitMessages(filter, {
          max: 1,
          time: 90000,
          errors: ['time']
        })
        .then(collected => {
            collected.first().delete();
            thisMessage = collected.first().content;
            let boi;
            msg.edit(':scroll: **| ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ ÿßŸÑÿ±ŸàŸÖ ÿßŸÑÿßŸÜ... :pencil2: **').then(msg => {
      
                message.channel.awaitMessages(filter, {
                  max: 1,
                  time: 90000,
                  errors: ['time']
                })
                .then(collected => {
                    collected.first().delete();
                    boi = collected.first().content;
                    msg.edit('‚úÖ **| ÿ™ŸÖ ÿßŸÑÿßÿπÿØÿßÿØ ÿ®ŸÜÿ¨ÿßÿ≠...  **').then(msg => {
        
                      message.channel.awaitMessages(filter, {
                        max: 1,
                        time: 90000,
                        errors: ['time']
                      })
                      let embed = new Discord.RichEmbed()
                      .setTitle('**Done The Leave Msg Code Has Been Setup**')
                      .addField('Message:', `${thisMessage}`)
                      .addField('Channel:', `${boi}`)
                      .setThumbnail(message.author.avatarURL)
                      .setFooter(`${client.user.username}`)
                     message.channel.sendEmbed(embed)
    welcome[message.guild.id] = {
leavechannel: boi,
leavemsg: thisMessage,
onoff: 'On',
leave: 'On'
    }
    fs.writeFile("./welcomer.json", JSON.stringify(welcome), (err) => {
    if (err) console.error(err)
  })
   } 
            )
        })
    })
})
    })
}})
    
client.on('message', message => {
           if (!message.channel.guild) return;

    let room = message.content.split(" ").slice(1);
    let findroom = message.guild.channels.find('name', `${room}`)
    if(message.content.startsWith(prefix + "setWelcomer")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
if(!room) return message.channel.send('Please Type The Channel Name')
if(!findroom) return message.channel.send('Cant Find This Channel')
let embed = new Discord.RichEmbed()
.setTitle('**Done The Welcome Code Has Been Setup**')
.addField('Channel:', `${room}`)
.addField('Requested By:', `${message.author}`)
.setThumbnail(message.author.avatarURL)
.setFooter(`${client.user.username}`)
message.channel.sendEmbed(embed)
welcome[message.guild.id] = {
channel: room,
onoff: 'On',
by: 'On',
dm: 'Off',
leave: 'Off'
}
fs.writeFile("./welcomer.json", JSON.stringify(welcome), (err) => {
if (err) console.error(err)
})
    }})
    

            client.on('message', message => {
  
    if(message.content.startsWith(prefix + "toggleLeave")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
        if(!welcome[message.guild.id]) welcome[message.guild.id] = {
            onoff: 'Off',
          leave: 'Off'
        }
          if(welcome[message.guild.id].leave === 'Off') return [message.channel.send(`**The Leave Msg Is __ùêéùêç__ !**`), welcome[message.guild.id].leave = 'On']
          if(welcome[message.guild.id].leave === 'On') return [message.channel.send(`**The Leave Msg Is __ùêéùêÖùêÖ__ !**`), welcome[message.guild.id].leave = 'Off']
          fs.writeFile("./welcome.json", JSON.stringify(welcome), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            })
          }
          
        })
client.on('message', message => {
  
    if(message.content.startsWith(prefix + "toggleWelcome")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
        if(!welcome[message.guild.id]) welcome[message.guild.id] = {
          onoff: 'Off'
        }
          if(welcome[message.guild.id].onff === 'Off') return [message.channel.send(`**The Welcome Is __ùêéùêç__ !**`), welcome[message.guild.id].onoff = 'On']
          if(welcome[message.guild.id].onoff === 'On') return [message.channel.send(`**The Welcome Is __ùêéùêÖùêÖ__ !**`), welcome[message.guild.id].onoff = 'Off']
          fs.writeFile("./welcome.json", JSON.stringify(welcome), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            })
          }
          
        })
        

        
        client.on('message', message => {
  
    if(message.content.startsWith(prefix + "toggleDmwelcome")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
        if(!welcome[message.guild.id]) welcome[message.guild.id] = {
          dm: 'Off'
        }
          if(welcome[message.guild.id].dm === 'Off') return [message.channel.send(`**The Welcome Dm Is __ùêéùêç__ !**`), welcome[message.guild.id].dm = 'On']
          if(welcome[message.guild.id].dm === 'On') return [message.channel.send(`**The Welcome Dm Is __ùêéùêÖùêÖ__ !**`), welcome[message.guild.id].dm = 'Off']
          fs.writeFile("./welcome.json", JSON.stringify(welcome), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            })
          }
          
        })

        client.on('message', message => {
  
            if(message.content.startsWith(prefix + "toggleInvitedby")) {
                if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
                if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
                if(!welcome[message.guild.id]) welcome[message.guild.id] = {
                  by: 'Off'
                }
                  if(welcome[message.guild.id].by === 'Off') return [message.channel.send(`**The Invited By Is __ùêéùêç__ !**`), welcome[message.guild.id].by = 'On']
                  if(welcome[message.guild.id].by === 'On') return [message.channel.send(`**The Invited By Is __ùêéùêÖùêÖ__ !**`), welcome[message.guild.id].by = 'Off']
                  fs.writeFile("./welcome.json", JSON.stringify(welcome), (err) => {
                    if (err) console.error(err)
                    .catch(err => {
                      console.error(err);
                  });
                    })
                  }
                  
                })
      client.on("guildMemberRemove", member => {
            if(!welcome[member.guild.id]) welcome[member.guild.id] = {
          onoff: 'Off',
          leave: 'Off'
        }
        
        if(welcome[member.guild.id].onoff === 'Off') return;
                if(welcome[member.guild.id].leave === 'Off') return;
    let welcomer = member.guild.channels.find('name', `${welcome[member.guild.id].leavechannel}`)
    if(!welcomer) return;
     welcomer.send(`${member} ${welcome[member.guild.id].leavemsg}`);
      })          

client.on("guildMemberAdd", member => {
            if(!welcome[member.guild.id]) welcome[member.guild.id] = {
          onoff: 'Off'
        }
        if(welcome[member.guild.id].onoff === 'Off') return;
    let welcomer = member.guild.channels.find('name', `${welcome[member.guild.id].channel}`)
    let memberavatar = member.user.avatarURL
      if (!welcomer) return;
      if(welcomer) {
         moment.locale('ar-ly');
         var h = member.user;
        let heroo = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setThumbnail(h.avatarURL)
        .setAuthor(h.username,h.avatarURL)
        .addField(': ÿ™ÿßÿ±ŸäÿÆ ÿØÿÆŸàŸÑŸÉ ÿßŸÑÿØÿ≥ŸÉŸàÿ±ÿØ',`${moment(member.user.createdAt).format('D/M/YYYY h:mm a')} **\n** \`${moment(member.user.createdAt).fromNow()}\``,true)
         .setFooter(`${h.tag}`,"https://images-ext-2.discordapp.net/external/JpyzxW2wMRG2874gSTdNTpC_q9AHl8x8V4SMmtRtlVk/https/orcid.org/sites/default/files/files/ID_symbol_B-W_128x128.gif")
     welcomer.send({embed:heroo});
      }})



client.on('guildMemberAdd',async member => {
            if(!welcome[member.guild.id]) welcome[member.guild.id] = {
          onoff: 'Off'
        }
    if(welcome[member.guild.id].onoff === 'Off') return;
    const Canvas = require('canvas');
    const jimp = require('jimp');
    const w = ['./welcome_4.png'];
          let Image = Canvas.Image,
              canvas = new Canvas(800, 300),
              ctx = canvas.getContext('2d');
          ctx.patternQuality = 'bilinear';
          ctx.filter = 'bilinear';
          ctx.antialias = 'subpixel';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
          ctx.shadowOffsetY = 2;
          ctx.shadowBlur = 2;
          ctx.stroke();
          ctx.beginPath();
   
          fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
              if (err) return console.log(err);
              let BG = Canvas.Image;
              let ground = new Image;
              ground.src = Background;
              ctx.drawImage(ground, 0, 0, 800, 300);
   
  })
   
                  let url = member.user.displayAvatarURL.endsWith(".webp") ? member.user.displayAvatarURL.slice(5, -20) + ".png" : member.user.displayAvatarURL;
                  jimp.read(url, (err, ava) => {
                      if (err) return console.log(err);
                      ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                   if (err) return console.log(err);
   
            ctx.font = '36px Arial';
            ctx.fontSize = '72px';
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.fillText(member.user.username, 545, 177);
           
            ctx.font = '16px Arial Bold';
            ctx.fontSize = '72px';
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.fillText(`Your The Member ${member.guild.memberCount}`, 580, 200);
           
            let Avatar = Canvas.Image;
            let ava = new Avatar;
            ava.src = buf;
            ctx.beginPath();
            ctx.arc(169.5, 148, 126.9, -100, Math.PI * 2, true);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(ava, 36, 21, 260, 260);
             
            let c = member.guild.channels.find('name', `${welcome[member.guild.id].channel}`)
            if(!c) return;
            c.sendFile(canvas.toBuffer());
   
  });
  });
  });

  const invites = {};

const wait = require('util').promisify(setTimeout);

client.on('ready', () => {
  wait(1000);

  client.guilds.forEach(g => {
    g.fetchInvites().then(guildInvites => {
      invites[g.id] = guildInvites;
    });
  });
});

client.on('guildMemberAdd', member => {
                    if(!welcome[member.guild.id]) welcome[member.guild.id] = {
                  by: 'Off'
                }
    if(welcome[member.guild.id].by === 'Off') return;
  member.guild.fetchInvites().then(guildInvites => {
    const ei = invites[member.guild.id];
    invites[member.guild.id] = guildInvites;
    const invite = guildInvites.find(i => ei.get(i.code).uses < i.uses);
    const inviter = client.users.get(invite.inviter.id);
    const logChannel = member.guild.channels.find(channel => channel.name === `${welcome[member.guild.id].channel}`);
    if(!logChannel) return;
      setTimeout(() => {
    logChannel.send(`Invited By: <@${inviter.id}>`);
  },2000)
  });
});

client.on("guildMemberAdd", member => {
                    if(!welcome[member.guild.id]) welcome[member.guild.id] = {
                  dm: 'Off'
                }
        if(welcome[member.guild.id].dm === 'Off') return;
  member.createDM().then(function (channel) {
  return channel.send(`:rose:  ŸàŸÑŸÉŸÖ ŸÜŸàÿ±ÿ™ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:rose: 
:crown:ÿßÿ≥ŸÖ ÿßŸÑÿπÿ∂Ÿà  ${member}:crown:  
ÿßŸÜÿ™ ÿßŸÑÿπÿ∂Ÿà ÿ±ŸÇŸÖ ${member.guild.memberCount} `) 
}).catch(console.error)
})


client.on('message', message => {

  if(message.content.split(' ')[0] == prefix + 'id') {
  if(!message.channel.guild) return;
 
  let args = message.content.split(' ').slice(1).join(' ');
 
         let defineduser = '';
         if (!args[1]) {
             defineduser = message.author;
         } else { // Run this if they did define someone...
             let firstMentioned = message.mentions.users.first();
             defineduser = firstMentioned;
         }
 
         const w = ['./id5.png','./id6.png'];
         var Canvas = require('canvas')
  var jimp = require('jimp')
 
          const millis = new Date().getTime() - defineduser.createdAt.getTime();
  const now = new Date();
  dateFormat(now, 'dddd, mmmm dS, yyyy');
  const stats2 = ['online', 'Low', 'Medium', 'Insane'];
  const days = millis / 1000 / 60 / 60 / 24;
           dateFormat(now, 'dddd, mmmm dS, yyyy');
               let time = `${dateFormat(defineduser.createdAt)}`
               var heg;
               if(men) {
                   heg = men
               } else {
                   heg = message.author
               }
              var mentionned = message.mentions.members.first();
                var h;
               if(mentionned) {
                   h = mentionned
               } else {
                   h = message.member
               }
         let Image = Canvas.Image,
             canvas = new Canvas(300, 300),
             ctx = canvas.getContext('2d');
         ctx.patternQuality = 'bilinear';
         ctx.filter = 'bilinear';
         ctx.antialias = 'subpixel';
 
         fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
             if (err) return console.log(err);
             let BG = Canvas.Image;
             let ground = new Image;
             ground.src = Background;
             ctx.drawImage(ground, 0, 0, 300, 300);
 
  })
    var mentionned = message.mentions.users.first();
 
     var client;
       if(mentionned){
           var client = mentionned;
       } else {
           var client = message.author;
 
       }
 
  var men = message.mentions.users.first();
             var heg;
             if(men) {
                 heg = men
             } else {
                 heg = message.author
             }
                 let url = defineduser.displayAvatarURL.endsWith(".webp") ? defineduser.displayAvatarURL.slice(20, 20) + ".png" : defineduser.displayAvatarURL;
                 jimp.read(url, (err, ava) => {
                     if (err) return console.log(err);
                     ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                         if (err) return console.log(err);
 
                         let Avatar = Canvas.Image;
                         let ava = new Avatar;
                         ava.src = buf;
                         ctx.drawImage(ava, 112 , 40, 75, 75);

                         var status;
     if (defineduser.presence.status === 'online') {
         status = 'ONLINE';
  ctx.fillStyle = `#2ce032`;
  ctx.beginPath();
  ctx.arc(179, 107, 10, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.fill();
 
     } else if (defineduser.presence.status === 'dnd') {
         status = 'DND';
         ctx.fillStyle = `#ff0000`;
  ctx.beginPath();
  ctx.arc(179, 107, 8, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.fill();
     } else if (defineduser.presence.status === 'idle') {
         status = 'IDLE';
         ctx.fillStyle = `#f4d32e`;
  ctx.beginPath();
  ctx.arc(179, 107, 10, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.fill();
     } else if (defineduser.presence.status === 'offline') {
         status = 'INVISIABLE';
         ctx.fillStyle = `#898988`;
  ctx.beginPath();
  ctx.arc(179, 107, 10, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.fill();
     }
 
 
                                               var time2;
       if(mentionned){
           var time2 = `${dateFormat(message.mentions.users.first.joinedAt)}`;
       } else {
           var time2 = `${dateFormat(message.member.joinedAt)}`;
 
       }
 
                         ctx.font = 'Bold 15px Arial ';
                         ctx.fontSize = '15px';
                         ctx.fillStyle = "#ffffff";
                         ctx.textAlign = "center";
                         ctx.fillText(status, 70 , 108 );
 
                          ctx.font = 'Bold 13px Arial';
                         ctx.fontSize = '13px';
                         ctx.fillStyle = "#ffffff";
                         ctx.textAlign = "center";
                         ctx.fillText(`${message.author.presence.game === null ? "No Status" : message.author.presence.game.name}`, 150.00   , 180  );
 
 
                         ctx.font = 'Bold 20px Arial ';
                         ctx.fontSize = '15px';
                         ctx.fillStyle = "#ffffff";
                         ctx.textAlign = "center";
                         ctx.fillText(`${defineduser.username}`, 150.50 , 140);
 
 
                         ctx.font = 'Bold 15px Arial';
                         ctx.fontSize = '15px';
                         ctx.fillStyle = "#ffffff";
                         ctx.textAlign = "center";
                         ctx.fillText(`#${defineduser.discriminator}`, 227  , 108);
 
                         var time2;
       if(mentionned){
           var time2 = `${dateFormat(message.mentions.users.first.joinedAt)}`;
       } else {
           var time2 = `${dateFormat(message.member.joinedAt)}`;
 
       }
 
                         ctx.font = 'Bold 13px Arial ';
                         ctx.fontSize = '13px';
                         ctx.fillStyle = "#ffffff";
                         ctx.textAlign = "center";
                         ctx.fillText(`${moment(defineduser.createdTimestamp).fromNow()}`, 179 , 226 );
                         ctx.font = 'Bold 13px Arial ';
                         ctx.fontSize = '13px';
                         ctx.fillStyle = "#ffffff";
                         ctx.textAlign = "center";
                         ctx.fillText(`${moment(h.joinedAt).format('YYYY/M/D HH:mm:ss')}`, 179 , 253);
 
  message.channel.sendFile(canvas.toBuffer())
 
 
         })
     })
 
 
 
 
  }
 
  })



let antibots = JSON.parse(fs.readFileSync('./antibots.json' , 'utf8'));
client.on('message', message => {
    if(message.content.startsWith(prefix + "antibots on")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
antibots[message.guild.id] = {
onoff: 'On',
}
message.channel.send(`**‚úÖ The AntiBots Is __ùêéùêç__ !**`)
          fs.writeFile("./antibots.json", JSON.stringify(antibots), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            });
          }

        })


client.on('message', message => {
    if(message.content.startsWith(prefix + "antibots off")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
antibots[message.guild.id] = {
onoff: 'Off',
}
message.channel.send(`**‚õî The AntiBots Is __ùêéùêÖùêÖ__ !**`)
          fs.writeFile("./antibots.json", JSON.stringify(antibots), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            });
          }

        })

client.on("guildMemberAdd", member => {
  if(!antibots[member.guild.id]) antibots[member.guild.id] = {
onoff: 'Off'
}
  if(antibots[member.guild.id].onoff === 'Off') return;
if(member.user.bot) return member.kick()
})

fs.writeFile("./antibots.json", JSON.stringify(antibots), (err) => {
if (err) console.error(err)
.catch(err => {
console.error(err);
});

})

const temp = JSON.parse(fs.readFileSync('./temp.json', 'utf8'));
client.on('message', async message => {
 if(message.channel.type === "dm") return;
  if(message.author.bot) return;
   if(!temp[message.guild.id]) temp[message.guild.id] = {
    time: "3000",
     category : 'click here',
      channel : 'click here'
       }
        if(message.content.startsWith('-temp on')){
         if(!message.member.hasPermission(`MANAGE_GUILD`)) return;
          var ggg= message.guild.createChannel('click here', 'category').then(cg => {
           var ccc =message.guild.createChannel('click here', 'voice').then(ch => {
            ch.setParent(cg)
             message.channel.send('**Done ,**')
              client.on('message' , message => {
               if(message.content === '#temp off') {
                if(!message.member.hasPermission(`MANAGE_GUILD`)) return;
                 cg.delete()
                  ch.delete()
                   message.channel.send('**Done ,**')
                    }
                     });
                      const time = temp[message.guild.id].time
                       client.on('message' , message => {
                        if (message.content.startsWith(prefix + "temptime")) {
                         if(!message.member.hasPermission(`MANAGE_GUILD`)) return;
                          let newTime= message.content.split(' ').slice(1).join(" ")
                          if(!newTime) return message.reply(`**${prefix}temptime <time>  \`1000 = 1s\`**`)
	                 if(isNaN(newTime)) return message.reply(`** The Time Be Nambers :face_palm: **`);
	                if(newTime < 1) return message.reply(`**The Time Be Up \`3000s\`**`)
                       temp[message.guild.id].time = newTime
                      message.channel.send(`**Temp Rooms Time Change To \`${newTime}\`**`);
                     }
                    });
                   client.on('voiceStateUpdate', (old, neww) => {
                  let newUserChannel = neww.voiceChannel
                 let oldUserChannel = old.voiceChannel
                temp[message.guild.id].category = cg.id
               temp[message.guild.id].channel = ch.id
              let channel = temp[message.guild.id].channel
             let category = temp[message.guild.id].category
            if(oldUserChannel === undefined && newUserChannel !== undefined && newUserChannel.id == channel) {
           neww.guild.createChannel(neww.displayName , 'voice').then(c => {
          c.setParent(category)
         let scan = setTimeout(()=>{
        if(!neww.voiceChannel) {
       c.delete();
      client.channels.get(channel).overwritePermissions(neww, {
     CONNECT:true,
    SPEAK:true
   })
  }
 }, temp[neww.guild.id].time);
  c.overwritePermissions(neww, {
   CONNECT:true,
    SPEAK:true,
     MANAGE_CHANNEL:true,
      MUTE_MEMBERS:true,
       DEAFEN_MEMBERS:true,
	MOVE_MEMBERS:true,
	 VIEW_CHANNEL:true
	  })
	   neww.setVoiceChannel(c)
            })
             client.channels.get(channel).overwritePermissions(neww, {
	      CONNECT:false,
	       SPEAK:false
		})
               }
              })
             })
           })
          }
         fs.writeFile("./temp.json", JSON.stringify(temp), (err) => {
        if(err) console.error(err)
       })
      });


client.login(process.env.BOT_TOKEN);